
Linux系统管理
	文件系统初步
	磁盘管理
	RAID
	LVM
	程序包安装
	网络管理
	sed命令
	进程管理
	内核管理
	系统启动流程
	定制、编译内核
	系统安装：kickstart, dhcp, pxe
	shell编程
	gawk

Linux磁盘及文件系统管理
	
	CPU, Memory(RAM), I/O

	I/O: Input and Output Devices

		磁盘：辅助存储设备
		网卡：

	文件接口：open(), read(), write(), close()

	设备类别：
		块(block)：随机访问，数据交换单位为“块”
		字符(character)：线性，数据交换单位为字符

	设备文件：FHS(LSB)
		/dev/: 设备
			设备文件，关联至设备的驱动程序

				设备号：
					major：主设备号，区别设备类别，用于标明所需驱动程序
					minor：次设备号，

				mknod命令：
					mknod [OPTION]... NAME TYPE [MAJOR MINOR]
						 -m, --mode=MODE

			设备文件的文件名：ICANN

	磁盘设备文件：
		IDE接口（ATA）：并行, 133MB/s
			两个IDE控制器：每个控制器可通过线缆接入两块磁盘，一主一从；
			/dev/hd[a-z][#]
				/dev/hda, /dev/hdb,
				/dev/hdc, /dev/hdd

		SCSI接口: 并行，Small Computer System Interface
			UltraSCSI 320, 320MB/s
		SATA接口：串行，Serial ATA,
			6Gpbs
		USB接口：串行，480MB/s
		SAS接口：串行	

			设备文件：/dev/sd[a-z][#]
				[a-z]：标记设备
				[#]：磁盘分区

		
		track: 磁道
		sector: 扇区
		cylinder: 柱面
			寻道时间：平均寻道时间

		MBR：0磁道0扇区，主引导扇区(master boot record)
			三部分：
				446bytes: bootloader，程序
				64bytes: 分区表
					16bytes：标记一个分区
						4个主分区：3主，1扩展-->n逻辑分区
				2bytes: 55AA, 当前MBR信息是否有效的标记；

				GPT：?

		分区标识方式：
			主分区或扩展分区：1-4
			逻辑分区：5+

	fdisk命令：
		1、查看已经识别的磁盘设备：
			# fdisk -l /dev/[hs]d[a-z]

		2、管理分区
			# fdisk DEVICE

				fdisk提供了一个交互式接口来管理分区，它有许多子命令，分别用于不同的管理功能；所有的操作均在内存中完成，没有直接同步到磁盘；
				常用命令：
					p: 显示现有分区表；
					n: 创建新分区
					d: 删除现有分区
					t: 修改分区ID
					l: 查看支持哪些分区ID
					w: 保存退出
					q: 不保存退出
					m: 显示帮助信息

				示例：/dev/sdb
					3主+1扩展（3个逻辑）
					2主+1扩展（4个逻辑）
					...

			查看内核是否已经识别新建分区：
				# cat /proc/partitions

			通知内核强制重读分区表：
				CentOS 5: partprobe /dev/DEVICE
				CentOS 6: partx, kpartx
					partx -a /dev/DEVICE
					kpartx -af /dev/DEVICE

					注意：成功读取分区，可能需要命令重复执行2次或以上；

			此外的工具：sfdisk, parted

	创建文件系统：

		文件系统：
			元数据：每个索引项称一个inode, (index node)
				inode table

				/var/logs/messages 
					根的inode --> 根目录对应的磁盘块 --> var对应的inode编号 --> 查inode table, 找到编号对应的inode --> var目录的磁盘块 --> logs 的inode编号 --> 查inode table, 找到logs目录的inode --> logs目录的磁盘块 --> 找到messages文件名对应的inode编号 -->查inode表，找到messages的inode编号对应的inode --> messages的磁盘块

					dentry

				链接文件：访问同一个文件数据不同路径
					硬链接：两个文件路径指向了同一个inode；
						创建方法：
							# cp -l SRC DEST
							# ln SRC DEST

							特性：
								(1) 目录不支持硬链接；
								(2) 硬链接不能跨文件系统；
								(3) 硬链接文件与原文件是指向同一个inode，创建硬链接文件会增加inode的引用计数；
					符号链接：链接文件是一个完全独立的新文件，但其指向了原文件的文件路径；
						特性：
							(1) 符号链接文件与原文件是两个各自独立文件；
							(2) 目录可以创建符号链接；
							(3) 可以跨文件系统；
							(4) 删除链接不影响原文件；但删除原文件，符号链接指向的文件路径将不复存在，因此，此时链接文件将变成失效的链接；

							其大小并非真正原文件大小，而是指向的原文件的文件路径字符串所包含的字节数；

						创建方法：
							ln -s SRC DEST

					bitmap索引

					block group: 
						bitmap: inode, block

				VFS: Virtual File System
					Linux文件系统：ext2, ext3, ext4, reiserfs, xfs, btrfs
					光驱：iso9660
					网络文件系统：nfs, cifs
					集群文件系统：gfs2, ocfs2
					分布式文件系统：ceph
					windows文件系统：ntfs, vfat
					伪文件系统: tmpfs, hugepagefs, proc, sysfs
					Unix的文件系统：FFS, UFS, JFS
					交换文件系统：swap

				文件系统管理工具：
					创建文件系统
						mkfs.ext2, mkfs.ext3, mkfs.xfs ... 
					检测文件系统
						fsck.ext2, fsck.ext3, fsck.ext4, fsck.xfs ...
					查看其属性
						dumpe2fs, tune2fs

				创建文件系统：
					mkfs.FSTYPE /dev/DEVICE
					blkid /dev/DEVICE

					mkfs -t FSTYPE /dev/DEVICE

					ext系列：
						mke2fs

回顾：
	磁盘分区
		MBR：Master Boot Record，512bytes
			446: bootloader
			64: 
			2

	文件系统：程序
		元数据区、数据区

		mkfs

Linux文件系统管理：
	
	VFS：
		日志文件系统：加速文件检测并修复的过程
			ext3, ext4, xfs
		非日志型文件系统：ext2

		非一致性：	

	ext系列文件系统：mke2fs
		mke2fs [OPTION]... /dev/DEVICE
			-t {ext2|ext3|ext4}：指明要创建的文件系统类型
				mkfs -t ext4 = mkfs.ext4 = mke2fs -t ext4
			-b {1024|2048|4096}：其上限由page frame决定
			-L LABEL：指定要使用的卷标
			-j: 相当于使用-t ext3
				mkfs.ext3 = mkfs -t ext3 = mke2fs -j = mke2fs -t ext3
			-i #: 指明inode与字节的比率；即，每多少字节给创建一个inode；
			-N #: 直接指明给此文件系统创建多少个inode
			-m #：指定预留空间的百分比；默认为5；

			-O [^]FEATURE

		UUID: 全局惟一标识符

		e2label: 
			查看：e2label /dev/DEVICE
			设定卷标：e2label /dev/DEVICE LABEL

		tune2fs：查看或修改ext系列文件系统的某些属性
			查看超级块中的数据信息：
				tune2fs -l /dev/DEVICE

			修改指定文件系统的属性：
				-j: ext2 --> ext3
				-L LABEL: 修改卷标；
				-m #: 调整预留空间的百分比；
				-O [^]FEATURE: 开启或关闭某种特性

				-o [^]mount_options: 开启或关闭某种默认挂载选项
					-o acl
					-o ^acl

		dumpe2fs命令：显示ext系列文件系统属性信息
			dumpe2fs [-h] /dev/DEVICE

	文件系统检测：

		因进程意外中止或系统崩溃等原因导致写入操作非正常终止时，可能会导致文件损坏；此时，应该修改修复文件系统；

			注意：应该离线进行；

		fsck:
			-t FSTYPE
				fsck -t FSTYPE = fsck.FSTYPE
			-a：自动修复所有错误
			-r: 交互式修复错误

		ext系列文件系统的专用工具：
			e2fsck
				-y: 对所有问题自动回复为yes; 
				-f: 即使文件系统处于clean状态，也要强制进行检测；

	Windows无法识别Linux上专用的文件系统，因此，有存储设备需要两种系统之间交叉使用时，应该使用windows支持的文件系统：
		# mkfs -t vfat /dev/DEVICE


	swap文件系统：
		Linux上交换空间必须使用独立的磁盘分区；
			fdisk /dev/DEVICE
				t命令调整其ID为82; 

		创建交换分区文件系统：mkswap命令
			mkswap [-L LABEL] /dev/DEVICE

	注意：在Linux系统上，所有的文件系统必须通过根文件系统的某个分支来访问；

	
	根文件系统：根关联到的分区
			有一定的要求：FHS

		其余所有的其它文件系统如果想要被访问，都只能够通过“关联”至根文件系统上的某个目录来实现；

			这种操作即所谓的“挂载”，也即mount；相反动作，即卸载，命令为umount

			挂载点：mount_point，即用于作为另一个文件系统访问入口的目录；

		mount命令：
			mount DEVICE MOUNT_POINT

				挂载点
					1、事先存在；
					2、应该使用别的进程未使用的目录；
					3、挂载点下原有的文件将被隐藏；

			mount：将显示当前系统已经挂载的所有文件系统的相关信息；

			mount [OPTION]... [-t FSTYPE] [-o OPTION] [DEVICE] MOUNT_POINT

				命令选项：
					-r: 只读挂载
					-w: read and write，读写挂载
					-t FSTYPE: 被挂载的设备上的文件系统类型；可省略，此时mount会自动使用blkid命令来判断之；
					-L LABEL: 以卷标的方式指定要挂载的设备，因此，此时DEVICE可省；
					-U UUID：以UUID的方式指定要挂载的设备，因此，此时DEVICE可省；
					-a: 自动挂载所有的支持自动挂载的设备（/etc/fstab文件中定义的支持自动挂载的设备）；
					-n: 默认情况下，设备挂载与否的改变结果会被保存于/etc/mtab中一份；-n选项用于变动时不更新此文件

					示例：
						# mount -U dea669ee-e769-46d9-86a8-88925a10278b /data/mydata

				-o OPTION，挂载选项：
					async：异步写入
					sync：同步写入，即使用同步I/O；
					atime/noatime：文件或目录在被访问时是否更新其访问时间戳；
					diratime/nodiratime：目录在文中时是否更新其访问时间戳；
					auto/noauto：设备是否支持mount命令使用-a选项时自动挂载；
					dev/nodev：此设备上是否创建设备文件；
					exec/noexec：是否允许执行此文件系统上的程序文件；
					suid/nosuid：是否支持此设备上的文件上使用suid权限；
					remount: 重新挂载；
					acl: 支持使用facl；
						# mount -o acl
						# tune2fs -o acl /dev/DEVICE： 打开acl为默认挂载选项；
					ro: 只读
					rw: 读写
					user/nouser: 是否允许普通挂载此文件系统

					所有挂载选项均未指明时，其默认为：
					defaults
              			Use default options: rw, suid, dev, exec, auto, nouser, async, and relatime.

              	另外一个使用技巧：
              		将某目录绑定至指定目录下，作为临时访问入口；
              			mount --bind 源目录  目标目录

            查看所有已经挂载设备的方法：
            	# mount
            	# cat /etc/mtab
            	# cat /proc/mounts

		umount命令：
			umount DEVICE
			umount MOUNT_POINT

			注意：正在被某进程访问的设备是不可以被卸载的；查看被什么进程所占用：
				# lsof MOUNT_POINT
				# fuser -v MOUNT_POINT

				# fuser -km MOUNT_POINT: 终止正访问挂载点的进程；

		df命令：
			df [OPTION]... [FILE]...
				-l: 仅显示本地文件系统的相关系统；
				-h: 单位换算；
				-i: 显示inode的使用情况而非磁盘块的；

		du命令：
			用于评估文件大小
				-s: 统计整个目录及内部所有文件总体大小；
				-h: human-readable

	交换分区：
		创建交换分区文件系统：mkswap

		free命令：查看内存使用状况
			-m
			-g

		启动交换分区：
			swapon [OPTION] [DEVICE]
				-a: 启用/etc/fstab文件中定义的所有交换分区

		禁用交换分区：
			swapoff DEVICE

	练习：
		1、创建一个10G分区，并格式为ext4文件系统；
			(1) 要求其block大小为2048, 预留空间百分比为2, 卷标为MYDATA, 默认挂载属性包含acl；
			(2) 挂载至/data/mydata目录，要求挂载时禁止程序自动运行，且不更新文件的访问时间戳；

		2、创建一个大小为1G的swap分区，并创建好文件系统，并启用之；


	文件系统相关的配置文件: /etc/fstab

		定义开机可自动挂载的文件系统，每行一个：
			6个字段：
				(1) 挂载的设备：
					设备文件
					LABEL
					UUID
					伪文件系统：如sysfs, proc, tmpfs等
				(2) 挂载点
					swap的挂载点仍为swap
				(3) 文件系统类型
				(4) 挂载选项
					defaults表示使用默认挂载选项；
					多个挂载选项间使用逗号分隔；如defaults,acl,noatime
				(5) 转储频率
					0：从不备份
					1: 每天备份
					2: 每隔一天备份
				(6) 自检次序
					0：不自检
					1：首先自检，通常只有根文件系统可首先自检
					2：次级自检，
					...

	练习：写一个脚本
		1、获取并列出当前系统上的所有磁盘设备；
		2、显示每个磁盘设备上每个分区相关的空间使用信息；


回顾：

	命令总结：fdisk, mkfs, mke2fs, mkswap, fsck, e2fsck, mount, umount, swapon, swapoff, tune2fs, dumpe2fs, df, du, mknod, ln, free, e2label, blkid, fuser, partx, kpartx, partprobe

	/etc/fstab：
		挂载的设备  挂载点  文件系统类型  挂载选项  转储频率  自检次序  


Linux RAID

	硬盘设备常见的接口类型：

		IDE
		SCSI：15000rpm
		SATA：6Gbps
		SAS：
		USB：

	SCSI, IDE

	RAID：Redundent Array Inexpensive Disks
		廉价冗余磁盘阵列

		Independent

		性能：将I/O分散至多个设备；
		冗余：将同一个数据至少存储在两个硬盘上；

		异或运算：
			1 1 0  
			0 1 1 

	RAID Level: 仅用于表明其组合方式的不同
		raid0：读、写均有提升；元冗余能力；空间：N*disk；至少两块
		raid1：写性能略有下降，读性能提升；有冗余能力；空间：disk；至少两块
		raid4：读、写性能提升；有冗余能力，但至多坏一块盘；空间：(n-1)*disk；至少三块盘；
		raid5：比起Raid4而言，无专门校验盘；读、写性能提升；有冗余能力，但至多一块盘；空间：(n-1)*disk；至少三块盘；
		raid6：有两个校验盘，至多允许同时损坏两块磁盘；读、写性能提升；有冗余能力；空间：(n-2)*disk；至少四块盘；
		raid10：至少需要四个盘；至多允许同时损坏半数的磁盘，但同一组镜像中两个磁盘不能同时损坏；读、写性能提升；有较好的冗余能力；n/2*disk；
		raid50：至少需要6个盘；同组raid5不允许同时坏两个盘，但不同组可同时各坏一个；读、写性能提升；有冗余能力；空间：

	JBOD：将多块硬盘串联在一起，当一个设备使用；

	md: multi disks

		mdadm：管理software RAID; 
			模式化的命令：

			-A：装配模式
			-C：创建模式
			-F：监控模式

				管理模式：-f, -r, a

			-D：显示指定RAID设备的详细信息；

			-C：创建模式专用选项
				-n #: 用于创建RAID设备的磁盘设备的个数；
				-l #: 指明RAID级别；
				-a yes|no: 是否为正在创建的raid设备自动创建设备文件；
				-c Chunk_Size：指明CHUNK大小；
				-x #: 对于有冗余能力的RAID级别，此选项为其指定可用的空闲盘的个数；

				md设备的设备文件默认为/dev/md#: #仅设备编号，而与级别无关；

				设备状态信息输出：/proc/mdstat

				示例：创建一个大小为10G的RAID0：
					注意：不应该使用同一个磁盘上的多个分区创建raid设备；


				示例：创建一个大小为10G的RAID5；

		watch命令的用法：
			watch [-n #] 'COMMAND'
				交互式查看，周期性地执行指定的COMMAND；
					-n # : 指明间隔时长；

			管理命令的使用：

				mdadm -D /dev/md#：查看指定设备的详细信息

				mdadm -a /dev/md# /dev/DEVICE: 在指定的md设备添加一个块设备；

				mdadm -r /dev/md# /dev/DEVICE: 在指定的md设备上移除一个块设备；

				mdadm -f /dev/md# /dev/DEVICE: 手动标记指定md设备上的某块设备为faulty状态；

			停止软RAID：
				mdadm -S /dev/md#：停止指定的RAID设备；将来使用时需要“装配（-A）”; 

			重新装配指定的软RAID：
				mdadm -A /dev/md# /dev/DEVICES

				可能会读取配置文件：/etc/mdam.conf

	练习：
		1、创建一个大小为10G的RAID1，要求有一个空闲盘，而且CHUNK大小为128k; 
		2、创建一个大小为4G的RAID5设备，chunk大小为256k，格式化ext4文件系统，要求可开机自动挂载至/backup目录，而且不更新访问时间戳，且支持acl功能；

	注意：有冗余能力的RAID仅是为了避免因硬件损坏而导致业务中止，也能避免因硬件损坏而导致数据丢失；它不能取代备份的功能；


bash脚本编程：
	
	流程控制语句：for循环

		for Var_Name in List; do
			循环体
		done

		List的生成方式：
			1、整数序列：{start..end}, 例如：{1..10}
			2、整数序列：seq start step end，例如：$(seq 1 2 10)
			3、命令的执行结果：例如，$(ls /var)

	变量类型：
		位置参数变量：在脚本中用于引用传递给脚本的参数
			$1, $2, ..., ${10}, ...
		特殊变量：
			$?: 保存上一条命令的执行结果成功与否的状态，用数字表示，0-255；0表示成功，非0均为失败；
			$0：在脚本中用于引用传递给脚本名称本身；
			$#: 保存传递给当前脚本的参数的个数；
			$*：保存传递给当前脚本的所有参数；
			$@：保存传递给当前脚本的所有参数；

		练习：写一个脚本
			(1) 接受一个以上文件路径作为参数；
			(2) 显示每个文件拥有的行数；
			(3) 总结说明本次共为几个文件统计了其行数；

				#!/bin/bash
				#
				echo "Files: $@."

				for file in $@; do
				    lines=$(wc -l $file | cut -d' ' -f1)
				    echo "$file has $lines line(s)."
				done

				echo "Total files: $#."

		练习：写一个脚本
			(1) 传递两个以上字符串当作用户名；
			(2) 创建这些用户；且密码同用户名；
			(3) 总结说明共创建了几个用户；

			#/bin/bash
			#
			for user in $@; do
				useradd $user
				echo $user | passwd --stdin $user &> /dev/null
			done

			echo "Total users: $#."

	算术运算：

		如何定义整型变量？
			(1) let Var_Name=INTEGER_VALUE
				let num1=3

			(2) declare -i Var_Name=INTEGER_VALUE
				declare -i num2=6

				两步：
					declare -i num3
					num3=7

		注意：即使没有定义变量类型为整型，字符型的整数依然可以参与算术运算，是因为bash会进行隐式的数据类型转换；

		bash的算术运算：
			(1) let: let Var_Name=ARITHMATIC_EXPRESSION
			(2) $[]: Var_Name=$[ARITHMATIC_EXPRESSION]
			(3) $(())：Var_Name=$((ARITHMATIC_EXPRESSION))
			(4) expr命令：Var_Name=$(expr EXPRESSION)
						  Var_Name=$(expr ARGU1 operator $ARGU2)

			算术运算：
				+
				-
				*
				/
				%：取模，取余数
				**：幂运算

			增强型赋值：
				变量于自身做某种算术运算，而后将结果存回自身；
					+=
					-=
					*=
					/=
					%=
					**=

				自加：++, 例如 let a++, 相当于a=$[$a+1]，也相当于let a+=1
				自减: --

		示例：计算100以内所有正整数之和；
		
			#!/bin/bash
			#
			declare -i sum=0

			for i in {1..100}; do
			    echo "i is: $i."
			    echo "sum is: $sum."
			    let sum=$[$sum+$i]
			done

			echo "Sumary: $sum"

		练习：计算100以内所有偶数之和；
			  计算100以内所有奇数之和；

			#!/bin/bash
			#
			declare -i evensum=0
			declare -i oddsum=0

			for i in $(seq 2 2 100); do
			    let evensum+=$i
			done

			for i in $(seq 1 2 100); do
			    let oddsum+=$i
			done

			echo "Even sum: $evensum."
			echo "Odd sum: $oddsum."			  

		练习：写一个脚本，新建20个用户，visitor1-visitor20；计算他们的ID之和；
		练习：写一脚本，分别统计/etc/rc.d/rc.sysinit、/etc/rc.d/init.d/functions和/etc/fstab文件中以#号开头的行数之和，以及总的空白行数；
		练习：写一个脚本，显示当前系统上所有默认shell为bash的用户的用户名、UID以及此类所有用户的UID之和；

		练习：写一个脚本，显示当前系统上所有，拥有附加组的用户的用户名；并说明共有多少个此类用户；


回顾：RAID
	RAID：独立冗余磁盘阵列
		性能提升或提供冗余能力；
		性能提升：0, 5, 10, 50
		冗余能力：1, 5, 10, 50
		空间利用率：
			5: (n-1)*disk
			6: (n-2)*disk
			10: n*disk/2

	bash编程：
		特殊变量：$#, $*, $@
		算术运算：
			let, $[], $(()), expr

			操作符：**, *, /, %, +, -
			增强赋值：*=, /=, %=, +=, -=

		帮助：help let

LVM: Logical Volume Manager
	
	lvm, lvm2

	dm: device mapper

	功用：将一个或多个底块设备（包括RAID）组织一个逻辑存储空间；
		其边界：可动态扩展或缩减；

	lv, multipath

	PE, LE
		Pysical Extent
		Logical Extent

	管理lv:
		pv: pvcreate, pvdisplay, pvs, pvscan, pvremove, pvmove
		vg: vgcreate, vgdisplay, vgs, vgscan, vgremove, vgextend, vgreduce
		lv: lvcreate, lvdisplay, lvs, lvresize, lvextend, lvreduce, lvremove

	示例：
		创建一个10G vg：

	PV:
		创建pv:
			准备块设备，调整其id为8e；
			pvcreate [-f] /dev/DEVICE

		查看
			# pvdisplay [/dev/DEVICE]
			# pvs

		移动pv上的pe到其它pv：
			# pvmove

		删除pv:
			# pvremove

	VG: 
		创建vg: 新增一个vg，并指明其包含哪个或哪些pv实现；
			# vgcreate VGNAME /dev/PV1...
			[-s|--physicalextentsize PhysicalExtentSize[bBsSkKmMgGtTpPeE]] 
      		[-t|--test] 
       		[-v|--verbose]

       	删除vg: 
       		# vgremove VGNAME...

       	缩减vg: 通过从vg中移除pv实现
       		注意：计划移除的pv不能包含已经存储数据的pe；如果有需要先使用pvmove移动到同vg内其它pv上；

       		pvmove /dev/SOME_PV
       		vgreduce VG_NAME /dev/some_PV

       	扩展vg: 向vg中添加更多的pv实现

       		vgextend VG_NAME /dev/some_PV...

    LV: Logical Volume
    	创建lv:
    		lvcreate -L #[bBsSkKmMgGtTpPeE] [-n|--name  LogicalVolume{Name|Path}]  VG_NAME

    		设备路径：
    			(1) /dev/VGNAME/LVNAME
    			(2) /dev/mapper/VGNAME-LVNAME

    			实际路径：/dev/dm-#

    		注意：lv的大小必须为pe的整数倍

    	移除lv: 
    		lvremove LV_PATH

    	扩展lv: 

    		存储设备有：物理边界
    		文件系统有：逻辑边界

    		扩展：先扩展物理边界，而后拉伸逻辑边界
    			lvextend, lvresize
    			resize2fs

    		如何扩展lv: 
    			1、先确定目标大小：要确保此lv所在vg中有足够的空闲可用；
    				2G --> 4G
    					4G
    					+2G
    			2、扩展物理边界
    				lvextend -L [+]#[bBsSkKmMgGtTpPeE] /dev/VGNAME/LVNAME
    			3、拉伸逻辑边界
    				resize2fs /dev/VGNAME/LVNAME 

    	缩减lv：

    		注意：
    			1、缩减要离线！
    			2、先缩减文件系统大小，再缩减lv的大小；

    		过程：
    			1、先确定缩减后的目标大小：要确保缩减后的大小能够容纳现在的所有数据；
    			2、卸载逻辑卷，并强制做文件系统一致性检查；
    				e2fsck -f /dev/VGNAME/LVNAME
    			3、缩减逻辑边界
    				resize2fs /dev/VGNAME/LVNAME #[bBsSkKmMgGtTpPeE]
    			4、缩减物理边界
    				lvreduce -L [-]#[bBsSkKmMgGtTpPeE] /dev/VGNAME/LVNAME

    	快照卷：
    		访问原卷上数据另一个路径，备份工具可以通过此路径完成数据备份；
    		快照卷自身仅是为备份工具提供一个时间点一致的访问路径；

    		备份开始之前创建快照卷，完成之后即可删除之；快照卷的生命周期；

    		如何保证通过快照所访问到的数据的时间点一致？
    			通过把那些要发生改变的位于原卷上的数据自动复制一份至快照卷进行的，因此，快照卷上的数据如果有效，则必须能完成存储原卷即将发生改变的所有的数据的原有版本。

    		创建快照卷：
    			(1) 快照卷要与原卷在同一卷组中，因此创建快照卷无须指定卷组；
    			(2) 快照卷大小要精心设定；另外，快照卷应该是只读的；

    		创建命令：
    			lvcreate -L SIZE -n Name -p r -s /dev/VGNAME/LVNAME

    练习：
    	1、创建一个由至少两个物理卷组成的大小为20G的卷组；要求，PE大小为8M；而在卷组中创建一个大小为5G的逻辑卷mylv1，格式化为ext4文件系统，开机自动挂载至/users目录，支持acl；
    	2、新建用户magedu；其家目录为/users/magedu，而后su切换至此用户，复制多个文件至家目录；
    	3、扩展mylv1至9G，确保扩展完成后原有数据完全可用；
    	4、缩减mylv1至7G，确保缩减完成后原有数据完全可用；
    	5、对mylv1创建快照，并通过备份数据；要求保留原有的属主属组等信息；

dd命令：
	dd if= of= bs= count=
		if: 源文件，用于指定数据流来源
		of: 目标文件，用于指定数据流存储目标
		bs: block size，一次io的数据量
		count: 复制多少个bs指定的block

	两个设备文件：
		/dev/null: bit bucket
		/dev/zero：泡泡机，吐零设备

	应用1：创建本地回环设备文件：
		dd if=/dev/zero of=/PATH/TO/SOMEFILE bs= count=

	应用2：备份MBR
		dd if=/dev/sda of=/backup/mbr.backup bs=512 count=1

	应用3：破坏其MBR
		dd if=/dev/zero of=/dev/sda bs=512 count=1


文本比较、补丁制作及打补丁工具：

	diff, patch

	diff [-u] FILE.old FILE.new > FILE.patch

	patch FILE.old < FILE.patch


回顾：lvm 
	
	pv, vg, lv
	功用：空间动态变化、快照

	pv --> vg --> lv

	dd命令：dd if= of= bs= count=

	Linux: diff & patch

	patch如何还原打了补了补丁以后的文件至原来的版本？


Linux网络属性管理(1)

	Bell(AT&T), PARC(Xerox)
		以太网

	计算机网络：共享底层通信信道

		CSMA/CD算法
		token环算法

	MAC: Media Access Control

	IP网络：Internet Protocol

		32bits: 每8bits一段，共4段
			8bits: 0-255
				0000 0000 - 1111 1111
				1.1.1.1

			地址被切割为两部分：
				左侧：区域标识，网络标识
				右侧：主机标识


		网桥：分隔 冲突域
		路由器：分隔 广播域
			将一个大网络分隔成多个小网络，每个网络都自己的网络地址；
			每个网络中可以存在多个主机，每个主机都有自己在本网络内惟一地址标识；

			完整地址：网络地址 主机地址

		IP地址分类：
			A, B, C, D, E

				0000 0000 - 1111 1111
			A类网络：
				0 000 0001 - 0 111 1111: 1-127
				N.H.H.H
			B类：
				10 00 0000 - 10 11 1111: 128-191
				N.N.H.H
			C类：
				110 0 0000 - 110 1 1111: 192-223
				N.N.N.H 
			D类：
				1110 0000 - 1110 1111: 224-239
			E类：
				1111 0000 - 1111 1111: 240-255

			子网掩码：网络位部分全为1，主机位部分全为0

				子网掩码：用于通过计算得出网络地址
				IP & Netmask

				1.1.1.1,

				0000 0001. 0000 0001.0000 0001.0000 0001 
				1111 1111. 0000 0000.0000 0000.0000 0000

				0000 0001. 0000 0000.0000 0000.0000 0000
				1.0.0.0

		网络间转发：IP地址中获取出的网络地址来进行的；
		本地主机间通信：MAC地址；

		地址解析：IP-->MAC
			ARP: Address Resolve Protocol

		进程地址：端口号
			1.1.1.1:80

		资源地址：具体的应用协议来各自定义具体的实现方式

		局域网：本地网络
			网络地址：路由器

	协议栈：分层设计
		分层模型：
			OSI模型：
				物理层(PL)：定义物理设备规范及电气信号特性；
				数据链接层(DLL)：本地网络通信，定义MAC地址；
				网络层(NL)：定义网络间通信，定义IP地址；
				传输层(TL)：进程间通信，定义进程地址；
				会话层(SL)：会话建立和拆除；
				表示层(RL)：数据表示方式；
				应用层(AL)：完成数据交换；
			TCP/IP模型：
				物理层
				互联网层
				传输层
				应用层

		传输层：
			UDP：User Data Protocol
				无连接的协议
			TCP: Tranport Control Protocol
				有连接的协议

	IP首部格式和TCP首部格式

	子网划分，路由协议(OSPF, rip2)

		交换机：switch, MAC地址表
			单工
			半双工
			全双工：没有冲突域

		路由器：路由表
			目标网络  经由的路径  开销

			OSPF: 路由协议
				学习生成路由表
			IP：可路由协议

		传输层：
			进程启动时向内核注册使用某端口，所以，当网络报文到达时，首先到达内核；

		应用层：
			进程负责处理应用层协议；


回顾：网络基础知识
	OSI：PL, DLL, NL, TL, SL, RL, AL
	TCP/IP：PL, NL, TL, AL

	数据包发送：AL, TL, NL, DLL
	数据包接收：DLL, NL, TL, AL

	本地网络中的主机间通信：MAC
		交换机：多接口网桥
	跨网络的主机间通信：
		网络间数据报文转发：网络地址(IP, Netmask), Router
		本地网络中的主机间通信：
		路由器：路由表 routing table
			生成方式：
				静态方式：手动添加
				动态方式：路由协议学习生成，OSPF
	进程间通信：
		Socket, IP:PORT
			Client (ip:port) <--> Server (ip:port)
	应用层间通信：
		应用层协议：
			smtp: simple mail transfer protocol
			http: hyper text transfer protocol

	通信子网，资源子网


Linux网络基础(2)

	IANA, ICANN

	IPv4: 
		A类：
			0 000 0001 - 0 111 1111: 1-127
			特性：N.H.H.H
			默认掩码：255.0.0.0
			网络数：1-126
				每个网络中的主机位：
					全1为：广播地址
					全0为：网络地址
				每个网络中可以容纳多少个主机：2^24-2
			回环：127.0.0.0/8

			私有地址：10.0.0.0/8
		B类：
			10 00 0000 - 10 11 1111：128-191
			特性：N.N.H.H
			默认掩码：255.255.0.0
			网络数：2^14
				每个网络中的主机：
					每个网络中可容纳多少个主机：2^16-2

			私有地址：172.16.0.0/16-172.31.0.0/16
		C类：
			110 0 0000 - 110 1 1111: 192-223
			特性：N.N.N.H
			掩码：255.255.255.0
			网络数：2^21
				每个网络中的主机位：
					每个网络中可容纳多少个主机：2^8-2

			私有地址：192.168.0.0/24-192.168.255.0/24
		D类：组播地址
		E类：预留地址

		NAT: Network Address Translation

	FQDN：Full Qualified Domain Name
		http://www.magedu.com

	Linux主机接入到TCP/IP网络：
		IP/Netmask
		路由：建立路径条目
			网络路由：目标是一个网络
			主机路由：目标是一个主机
			默认路由：目标是所有的非本地网络

			注意：下一跳路由接口的地址必须与本地主机的某个地址在同一网络中；
		DNS服务器指向：
			主DNS服务器
			备用DNS服务器
			第三备用DNS服务器

		配置IP及Netmask：
			静态：手工指定
			动态(DHCP):
				前提：本地物理网络要有一个DHCP服务器动态提供地址

			静态配置地址：
				ifconfig命令
				ip命令
				GUI工具
				TUI工具
				编辑配置文件

			Interface名称：
				以太网：ethX，例如eth0, eth1
						ensX
						emX
				PPP网络：pppX
				本地环回接口：lo, 仅用于本机上进程间基于内核完成通信
					127.0.0.1

			ifconfig命令：
				查看接口：
					ifconfig [Interface]
						-a: 包括未激活状态的所有接口

					MTU: 最大传输单元
				启用或禁用：ifconfig IFNAME up|down
					启用：ifup IFNAME
					禁用：ifdown IFNAME
				设定IP地址：
					ifconfig IFNAME IP/Netmask [up]
						注意：CIDR格式的掩码
					ifconfig IFNAME IP netmask NETMASK
						注意：完整格式的掩码，即类似255.255.0.0
					设定的地址会立即送往内核，因此，会立即生效；但不会永久有效；

			ping命令：用ICMP的ECHO_REQUEST报文测试主机间的连通性
				ping [OPTIONS] DESTINATION
					-c #: 发送的ping报文次数；
					-s #: 发送的探测报文大小；
					-w #：ping命令运行时长；

			练习：写一个脚本
				1、使用ping命令探测172.16.250.1-172.16.250.254之间的所有主机的在线状态；
					在线的主机使用绿色显示；
					不在线的主使用红色显示；

			route命令：路由管理
				查看本机内核路由表：
					route 
						-n: numeric，数字格式显示地址
				添加路由：新增路由条目，用户告诉本机至某目标网络或主机要经由的下一跳路由
					route add [-net|-host] TARGET gw GATEWAY [dev IFNAME]

						示例：到达192.168.0.0/24网络，经由172.16.0.1网关；
								# route add -net 192.168.0.0/24 gw 172.16.0.1
							  到达192.168.1.1主机，经由172.16.0.1网关；
							  	# route add -host 192.168.1.1 gw 172.16.0.1
							  设定默认网关：
							  	# route add -net 0.0.0.0 gw 172.16.0.1
							  	# route add default gw 172.16.0.1

				删除路由：
					route del [-net|-host] TARGET gw GATEWAY [dev IFNAME]

					示例：删除上述配置的默认路由
						# route del -net 0.0.0.0 gw 172.16.0.1

				注意：所有配置立即发往内核中的协议栈，所以立即生效；不会永久有效；

			配置DNS服务器指向：
				/etc/resolv.conf

				指令：
					nameserver DNS_SERVER_IP

				测试命令：
					dig

					测试能否解析某个FQDN(正向解析)：
						dig -t A FQDN

					测试能否解析某个IP为FQDN(反向解析):
						dig -x IP

		配置IP、Netmask、网关、DNS服务指向的第二种方式：
			setup --> Network Configurations

			注意：此种配置方式的配置结果是保存至配置文件；生效方法：
				重启网络接口的相关服务
				重启系统

			网络管理的相关服务有两个：
				NetworkManager
				network

				查看其能否开机运行：
				# chkconfig --list  | grep -E "(NetworkManager|network)"

				启用或禁止开机自动运行：
				# chkconfig SERVICE_NAME on|off

				立即启动、关闭或重启指定服务：
				# service SERVICE_NAME start|stop|restart
				# /etc/init.d/SERVICE_NAME start|stop|restart

		配置IP、Netmask、网关、DNS服务指向的第三种方式：

			每个网络接口都有一个配置文件：/etc/sysconfig/network-scripts/ifcfg-IFNAME
				PARAMETER=VALUE

			DEVICE=eth0
			BOOTPROTO=none
			HWADDR=08:00:27:2d:14:19
			NM_CONTROLLED=yes
			ONBOOT=yes
			TYPE=Ethernet
			UUID="c9f7b242-abbf-4a34-8316-8c2c0e9a57c0"
			IPADDR=172.16.100.11
			NETMASK=255.255.0.0
			GATEWAY=172.16.0.1
			DNS1=172.16.0.1
			IPV6INIT=no
			USERCTL=no

			常用参数：
				DEVICE：此配置文件所关联到的设备，其值通常应该ifcfg-IFNAME中的IFNAME；
				BOOTPROTO：启动此设备时使用的配置协议，取值有static(手动配置)、none(手动配置)、dhcp或bootp(动态配置)；
				HWADDR：网卡的MAC地址，此地址应该与网卡设备ROM中固定的地址保持一致；
				NM_CONTROLLED: NM即NetworkManager的简写，建议设定为no; 
				ONBOOT：此设备是否随OS启动而激活；
				TYPE：设备类型，通常有“Ethernet”，“Bridge”；
				UUID：
				IPADDR：此接口的IP地址；
				NETMASK：子网掩码；
				GATEWAY：网关；
				DNS1：DNS服务器指向的主DNS服务器；
				DNS2:
				DNS3:
				IPV6INIT：是初始化ipv6协议地址；
				USERCTL：是否允许普通用户管理此接口；
				PEERDNS：当BOOTPROTO的值为dhcp时，是否允许dhcp服务器提供的dns服务指向覆盖本地手动配置的DNS服务器指向；

			注意：重启网络服务network服务后方能生效；

		静态路由配置文件：/etc/sysconfig/network-scripts/route-IFNAME
			配置方式一：
				每一行定义一个路由条目
					DESTINATION via GATEWAY

					例如：
					192.168.0.0/24 via 172.16.0.2
					192.168.1.1 via 172.16.0.3

			配置方式二：
				每三行定义一个路由条目：
					ADDRESS#=
					NETMASK#=
					GATEWAY#=

					例如：
					ADDRESS1=192.168.0.0
					NETMASK1=255.255.255.0
					GATEWAY1=172.16.0.2

			注意：两种方式不能混合使用；

		配置IP、Netmask、网关服务指向的第四种方式：

			ip命令
				ip [ OPTIONS ] OBJECT { COMMAND | help }

       			OBJECT := { link | addr | route }
       				link：链接接口，如eth0
       				addr：管理接口上的地址
       				route: 管理路由

       			link: 
       				set: 设定接口属性
       					ip link set DEVICE 
       						{up|down}：启用或禁用接口；
       						promisc { on | off }：是否支持混杂模式；
       						name NEWNAME：设定接口使用新名字；
       				show: 显示接口状态，例如启用的特性，HWADDR等；
       					ip link show [DEVICE]

       			addr：管理地址
       				add：添加地址
       				del：删除地址
       					ip addr { add | del } IFADDR dev STRING
       						示例：ip addr add 172.16.200.33/16 dev eth0
       				
       				show：
       					ip addr show [dev IFNAME]
       				flush：
       					ip addr flush [dev IFNAME]

       			route: 管理路由
       				list|show: 显示路由
       					ip route list 

       				add: 添加路由
       					ip route add DESTINATION via GATEWAY [dev IFNAME]

       					示例：设定默认网关
       						ip route add defalut via 172.16.0.1

       				del: 删除路由
       					ip route del DESTINATION 

       					例如：# ip route del 192.168.0.0/24

       	如何给接口配置多个地址的其它方式：
       		(1) ifconfig命令
       			网卡接口的别名：ethX:Y，例如eth0:0, eth0:1

       			ifconfig IF_ALIAS IPADDR netmask NETMASK [up]

       		(2) 配置文件
       			/etc/sysconfig/network-scripts/ifcfg-IF_ALIAS，例如ifcfg-eth0:0
       				DEVICE=IF_ALIAS
       				BOOTPROTO={static|none}：别名的地址不能动态获取；
       				IPADDR
       				NETMASK
       				ONBOOT

       	配置主机名：
       		(1) hostname命令
       		(2) 内核参数：/proc/sys/kernel/hostname
       			# echo "HOSTNAME" > /proc/sys/kernel/hostname

       		配置文件：/etc/sysconfig/network
       			HOSTNAME=www.magedu.com

       	网络管理的几个常用工具：
       		(1) ping
       		(2) traceroute IP
       			探测到达目标主机中间所经过网关设备；
       		(3) mtr HOST
       			合并了ping与traceroute命令的功能的网络诊断工具；

       	网络状态探测工具：
       		(1) netstat
       			-r: 显示路由表
       			-n: numeric，数字显示，不反解IP地址至主机名；

       			-t: tcp协议的相关连接
       			-u: udp协议的相关连接
       			-l: 显示处于监听状态(即等待别的进程连接访问); 
       			-a: 显示所有连接，对于tcp而言即处于各种状态；
       			-p: 显示相关连接的关联到的进程的名字及PID; 

       			常用组合：-rn, -tnl, -unl, -tunl, -tan, -tnlp
       		(2) ss
       			-t: tcp协议相关的连接
       			-n: 数字格式
       			-u: udp协议相关的连接
       			-l：处于监听状态
       			-a: 所有连接
       			-e: 显示扩展信息
       			-m: 显示使用信息
       			-o state {established|fin_wait_1|fin_wait_2|listening}

       			常用组合：-tnl, -unl, -tan, -tunl, -tnlp
       		(3) iftop：以连接为中心显示带宽占用情况
       			iftop [-i IFNAME]
       		(4) nethogs: 以进程为中心显示带宽占用情况
       			nethogs [IFNAME]

       	网络安全工具：
       		(1) nmap
       		(2) ncat
       		(3) tcpdump


回顾：Linux的网络属性配置

	命令总结：ifconfig, route, ip, ping, traceroute, mtr, netstat, ss, iftop, nethogs, dig, ifup, ifdown, chkconfig, service
	网络接口的配置文件：/etc/sysconfig/network-scripts/ifcfg-IFNAME
		DEVICE, BOOTPROTO, TYPE, HWADDR, ONBOOT, IPADDR, NETMASK, GATEWAY, DNS1, DNS2, NM_CONTROLLED

	静态路由的配置文件：/etc/sysconfig/network-scripts/route-IFNAME
		DESTINATION via NEXT_HOP

	关闭：
		chkconfig NetworkManager off
		service NetworkManager stop

Linux系统上的程序包管理(1)

	程序包以源代码形式提供：
		c语言
		c++语言

		perl语言
		python语言
		ruby语言

		INSTALL, README

		API: Application Programming Interface
		ABI：Application Binary Interface

	程序的组成的部分：
		编译之前：源代码
		编译之后：
			二进制程序
			库文件
			配置文件
			帮助文件（手册、文档）

			二进制程序：/bin, /sbin, /usr/bin, /usr/sbin, /usr/local/bin, /usr/local/sbin, /opt/bin, /opt/sbin
			库文件：/lib, /lib64, /usr/lib, /usr/lib64, /usr/local/lib, /usr/local/lib64
			配置文件：/etc, /etc/DIR, /usr/local/{etc,conf}
			帮助文件：/usr/share/man, /usr/share/doc, /usr/local/share/man

			httpd: /usr/local/apache
				bin, sbin, conf, lib, lib64, share/man

			注意：有些特殊的应用程序可能会将可执行文件放置于libexec目录；


	程序包管理器
		应用程序打包：有特定格式
		对兼容的程序包进行管理：
			安装、卸载、升级、查询

		注意：制作成的二进制格式程序与平台有相关性，所以，通常需要制作各种流行平台所兼容的版本；

	编译：
		C程序包
			源代码（文本）--> 预处理 --> 编译 --> 汇编 --> 链接

			编译时，根据是否将被调用的库文件直接打包进生成的二进制程序文件，编译方式可分为两类：
				动态链接：不将被调用的库文件打包进来，而是运行时去装载它；
				静态链接：将被调用的库文件打包进来，将来运行时，可自己完全独立运行，而无须外部库文件运行

	程序包：
		源代码：appname-VERSION.tar.gz, appname-VERSION.tar.bz2, appname-VERSION.tar.xz
		包管理器(rpm)格式：
			appname-VERSION-RELEASE.ARCH.rpm

	常见的包管理器：
		.deb: Debian
		.rpm: Red hat Package Manager, RPM is Package Manager

	rpm包命名格式：
		appname-VERSION-RELEASE.ARCH.rpm
			VERSION:
				major: 主版本号
				minor: 次版本号
				release: 发行号

			RELEASE: 包自身的修订号；有时候还会包含适用于的OS信息；比如bash-4.3.2-2.centos6.x86_64.rpm中的2.centos6
			ARCH: 适用的平台
				x86: i386, i486, i586, i686
				x86_64: x86_64, amd64
				powerpc: ppc
				noarch: 跟平台无关；

	想象一种场景：testapp有30种功能，其中有10种常用，有6种次常用，余下的14种极少用；
		分包机制：
			核心包，主包：命名与源项目名称一致；
				bash-4.3.2-2.centos6.x86_64.rpm
			子包（支包）：命令为源项目名称后附加支包中的文件提供的功能组成
				bash-devel-4.3.2-2.centos6.x86_64.rpm

	获取程序包的途径：
		1、系统的发行光盘镜像或官方站点（或站点镜像服务器）；

			挂载光盘：
				mount -r /dev/cdrom /media/cdrom

			官方站点，镜像：
				mirrors.sohu.com
				mirrors.163.com
				mirrors.aliyun.com

		2、程序包的官方站点

		3、第三方组织：epel
			教室：http://172.16.0.1/fedora-epel/6/

		4、搜索引擎
			http://rpmfind.net
			http://rpm.pbone.net
			http://pkgs.org

		建议：安装之前要验正的其合法性
			来源合法
			包的完整性

	CentOS系统上程序rpm包管理：
		安装、升级、卸载、查询、检验

		通过rpm命令完成

	安装：
		rpm {-i|--install} [install-options] PACKAGE_FILE1...

		-h: hash，以#来表示安装进度；
		-v, --verbose：显示安装过程中的详细信息；
			-vv: 
			-vvv：

		安装时常用的组合: -ivh, -ivvh

		--test：不执行真正的安装过程，而仅报告依赖关系及冲突信息等；

		程序包之间存在依赖关系：
			由众多目的单一的小程序组成；结果程序包之间存在相关性；
				X --> Y
				X --> Y --> (M,N) --> ...
				X <--> Y

		忽略依赖关系：
			副作用：能安装成功，但未必能成功运行；

			--nodeps

		覆盖安装：重新安装并覆盖原有的文件
			--replacepkgs

		强制安装：
			--force

	升级：

		 rpm {-U|--upgrade} [install-options] PACKAGE_FILE ...
		 	-U: 升级或安装

		 rpm {-F|--freshen} [install-options] PACKAGE_FILE ...
		 	-F：升级

		 组合：-Uvh, -Fvh

		 --test
		 --nodeps
		 --force
		 --oldpackage：降级到旧版本；

		注意：一定不要对内核执行升级；Linux允许多内核共存，所以，可以直接安装多个不同版本内核；

		注意：如果程序包的配置文件安装后曾被修改，升级时，新版本的文件不会覆盖老版本的配置文件，而把新版本的配置文件重命名(加后缀.rpmnew)后保存；

	
	卸载：

		移除已经安装的程序包

		 rpm {-e|--erase} [--allmatches] [--nodeps] [--test] PACKAGE_NAME ...

		 	简单用法：rpm -e PACKAGE_NAME...

		 	--nodeps：忽略依赖关系；
		 	--test: 测试卸载；dry-run模式；
		 	--allmatches: 如果一个程序包同时安装多个版本，则此选项一次全部卸载之；

		 注意：如果程序包的配置文件安装后曾被修改，卸载时，此文件通常不会被删除，而是被重命名（加后缀.rpmsave）后留存；

	查询：
		查询某包是否已经安装，以及检查安装的所有包；还可以查看某包的详细信息；

		rpm {-q|--query} [select-options] [query-options]

		[select-options]：
			1、查询某包或某些包是否安装：
				rpm -q PACKAGE_NAME...

			2、查询已经安装的所有包：
				rpm -qa

			3、查询某文件是由哪个包安装生成：
				rpm -qf /PATH/TO/SOMEFILE

			4、查询尚未安装的包文件的相关信息
				-p
				# rpm -qpi PACKAGE_FILE



		[query-options]：
			1、查询某包的简要说明信息：
				rpm -qi PACKAGE_NAME

			2、查询某包安装生成的文件列表：
				rpm -ql PACKAGE_NAME

			3、查询某包安装完成后生成的所有配置文件：
				rpm -qc PACKAGE_NAME

			4、查询某包安装完成后生成的所有帮助文件：
				rpm -qd PACKAGE_NAME

			5、查看某包制作时随版本变化的changelog信息：
				rpm -q --changelog PACKAGE_NAME

			6、查询某包提供的capabilities：
				rpm -q --provides PACKAGE_NAME

			7、查询某包所依赖的capabilities：
				rpm -q --requires PACKAGE_NAME

			8、查询某包安装或卸载时执行脚本：
				rpm -q --scripts PACKAGE_NAME

					脚本有四类：
						preinstall: 安装过程开始之前执行的脚本；
						postinstall: 安装过程完成之后执行的脚本；
						preuninstall: 卸载开始之前执行的脚本 ；
						postuninstall: 卸载过程完成之后执行的脚本；

	校验：
		查询包安装之后生成的文件是否发生了改变

		rpm {-V|--verify} [select-options] [verify-options]

		常见用法：rpm -V PACKAGE_NAME

	       S file Size differs
	       M Mode differs (includes permissions and file type)
	       5 digest (formerly MD5 sum) differs
	       D Device major/minor number mismatch
	       L readLink(2) path mismatch
	       U User ownership differs
	       G Group ownership differs
	       T mTime differs
	       P caPabilities differ


	程序包的合法性验正：
		来源合法：
			由我们信任的制作者提供
			依赖于：制作者的数字签名；签名是作者使用自己的私钥加密程序包的特性码进行的；
		内容合法：
			包未被二次修改；完整性校验成功
			依赖于：制作者提供的程序特征码；
				验正方式：安装者用同样的特征码提取算法提取程序包的特征码，并与原作者提供的相比较；

		验正其光盘中程序包的来源及完整性：
			rpm --import /path/to/RPM-GPG-KEY-FILE

			例如：# rpm --import RPM-GPG-KEY-CentOS-6

			验正：rpm {-K|--checksig} PACKAGE_FILE
				--nosignature: 不检查来源合法性
				--nodigest: 不检查完整性

	rpm管理器数据库：/var/lib/rpm

		重建数据库：
			 rpm {--initdb|--rebuilddb} [-v] [--dbpath DIRECTORY]

			 --initdb: 初始化数据库，即数据库完全不存时，可新建之；

			 --rebuilddb: 无论当前数据存在与否，都会直接重建此库；

	总结：
		基本管理：安装、升级、卸载、查询和校验；
		合法性验正；
		数据库管理；

	博客作业：rpm程序包管理


回顾：
	
	程序包的组成部分：二进制程序、库文件、配置文件、帮助文件
	API, ABI

	appname-VERSION.tar.{gz,bz2,xz}，源代码 

	打包：使用包管理器
		deb, rpm

	管理:
		安装：-ivh
		升级：-Uvh, -Fvh
		查询：-q, -qp
			-i, -l, -f, -c, -d, --scripts, --changelog
		卸载：-e
		校验：-V

	合法性：
		--import
		--checksig, -K

	数据库重建：--initdb, --rebuilddb

Linux程序包管理(2)

	update, yellowdog update modifier = yum

	yum: 自行解决依赖关系
		X --> Y

		C/S架构：

		文件服务的服务器：
			ftp服务
			http服务
			本地文件目录
			NFS服务

	yum相对应于rpm来说：
		rpm为基础包管理器
		yum则是rpm的前端工具

		仓库指向的路径：repodata目录所在的父目录

		http://172.16.0.1/cobbler/ks_mirror/CentOS-6.6-x86_64/

	yum命令行工具：
		配置文件：指向仓库的位置以及相关的各种配置信息；每个yum命令行可以同时指向多个仓库，仓库间可以优先级等相关的配置；

		有两部分组成：
			主配置文件：/etc/yum.conf
				为各仓库指向提供公共配置文件；
			各仓库的定义：/etc/yum.repos.d/*.repo

				directive=VALUE

				Note: 文件以.repo结尾；每个repo配置文件中可以配置一至多个仓库；

				[main]：提供公共配置信息

		各仓库配置
		[repositoryid]
			# 对于当前系统的yum来讲，此repositoryid用于惟一标识此repository指向，因此，其必须惟一；
		name= 
			# 当前仓库描述信息；
		baseurl=url://path/to/repository/
			# 指明repository的访问路径；通常为一个文件服务器上输出的某repository；

			url:
				ftp服务
					ftp://SERVER/PATH/TO/REPOSITORY
				http服务
					http://SERVER/PATH/TO/REPOSITORY
				本地目录：
					file:///PATH/TO/REPOSTIROY

		enabled={1|0}
			此仓库是否可被使用
		gpgcheck={1|0}
			是否对程序包做校验
		gpgkey=url://path/to/keyfile
			指明gpgkey文件路径；
		cost=#
			指明当前repository的访问开销，默认为1000；

		教室环境中可用的仓库：
			DVD1: http://172.16.0.1/cobbler/ks_mirror/CentOS-6.6-x86_64/
			DVD2: http://172.16.0.1/centos/6/extras/x86_64/
			epel: http://172.16.0.1/fedora-epel/6/x86_64/

	yum命令：
		yum [options] [command] [package ...]

       command is one of:
        * install package1 [package2] [...]
        * update [package1] [package2] [...]
        * update-to [package1] [package2] [...]
        * check-update
        * upgrade [package1] [package2] [...]
        * upgrade-to [package1] [package2] [...]
        * distribution-synchronization [package1] [package2] [...]
        * remove | erase package1 [package2] [...]
        * list [...]
        * info [...]
        * provides | whatprovides feature1 [feature2] [...]
        * clean [ packages | metadata | expire-cache | rpmdb | plugins | all ]
        * makecache
        * groupinstall group1 [group2] [...]
        * groupupdate group1 [group2] [...]
        * grouplist [hidden] [groupwildcard] [...]
        * groupremove group1 [group2] [...]
        * groupinfo group1 [...]
        * search string1 [string2] [...]
        * shell [filename]
        * resolvedep dep1 [dep2] [...]
        * localinstall rpmfile1 [rpmfile2] [...]
           (maintained for legacy reasons only - use install)
        * localupdate rpmfile1 [rpmfile2] [...]
           (maintained for legacy reasons only - use update)
        * reinstall package1 [package2] [...]
        * downgrade package1 [package2] [...]
        * deplist package1 [package2] [...]
        * repolist [all|enabled|disabled]
        * version [ all | installed | available | group-* | nogroups* | grouplist | groupinfo ]
        * history [info|list|packages-list|packages-info|summary|addon-info|redo|undo|rollback|new|sync|stats]
        * load-transaction [txfile]
        * check
        * help [command]

    仓库管理：
    	repolist: 列出已经配置的所有可用仓库	
    		repolist [all|enabled|disabled]	

    缓存管理：
    	clean：清理缓存
    		clean [ packages | metadata | expire-cache | rpmdb | plugins | all ]
    	makecache: 缓存创建
    		自动连接至每一个可用仓库，下载其无数据，将其创建为缓存；

    程序包查看：
    	yum list [all | glob_exp1] [glob_exp2] [...]

    	yum list {available|updates|installed|extras|obsoletes} [glob_exp1] [...]

    	grouplist [hidden] [groupwildcard] [...]

    程序包安装：
    	install package1 [package2] [...]

    	Note: 只需要提供包名；

    	如果某包有在不同仓库中有多个不同版本，默认会安装最新版本；

    	如果要安装指定版本：install PACKAGE-VERSION ...

    重新安装（覆盖安装）
    	reinstall package1 [package2] [...]

    程序包升级：
    	update [package1] [package2] [...]

    程序包降级：
    	downgrade package1 [package2] [...]

    检查有哪些升级可用：
    	check-update

    卸载：
    	remove | erase package1 [package2] [...]

    	所有依赖于正卸载的程序包的程序包会被一并卸载；

    查询：
    	查询程序的相关简要信息：info PACKAGE ...

    	在包名和sumary信息中搜索指定的关键字：search KEYWORD ...

    	查询指定文件由哪个程序包安装生成：provides|whatprovides /PATH/TO/SOMEFILE

    安装或升级本地的程序包文件：
    	localinstall rpmfile1 [rpmfile2] [...]

    	用于安装仓库中并不存在的程序包文件，这些程序包有可能又依赖于仓库中的某些程序包；

    	localupdate rpmfile1 [rpmfile2] [...]

    包组管理：
    	列出所有包组：grouplist
    	显示指定包组详情：groupinfo group1 [...]

    	安装：groupinstall group1 [group2] [...]

    	卸载：groupremove group1 [group2] [...]

    	升级：groupupdate group1 [group2] [...]

    	Note: 可直接用install、remove或update来管理包组：
    		@GROUP_NAME

    		yum install @"Server Platform Development"

    yum命令的可用选项：
    	-y: 自动回答为“yes”
    	--disablerepo=: 临时禁用在配置文件中配置并启用的某repository；
    	--enablerepo=：临时启用指定的某repo；
    	--nogpgcheck: 禁止做包校验；

    练习：配置使用epel源，而后安装zabbix程序包；
    	http://172.16.0.1/fedora-epel/6/x86_64/


    yum有内置变量，用于保存当前平台的相信息；
    	(1) $raleasever: 当前OS发行版的主版本号；
    		例如，对CentOS 6.6 x86_64，主版本号为6；
    	(2) $arch：平台
    		i386, i486
    	(3) $basearch: 基础平台, 例如i686, i586, i486以及i386的基础平台同为i386；
    	(4) $YUM0-$YUM9

    	假如：
    		baseurl=http://repo.magedu.com/centos/$releasever/$basearch
    		当前系统为CentOS 6.6 x86_64
    			http://repo.magedu.com/centos/6/x86_64

    如何使用发行版光盘作为yum repository
    	(1) 挂载光盘到指定挂载点，如/media/cdrom
    	(2) 新建yum repo配置文件，类似如下所示：
		[dvdbase]
		name=CentOS 6.6 X86_64 on dvd1
		baseurl=file:///media/cdrom
		gpgcheck=0
		enabled=1   	


    自己创建yum仓库：
    	(1) 在基于发行版安装树安装createrepo程序包；
    	(2) 确定repository输出方式：
    		本地输出：提供一个放置rpm包的本地路径；
    		网络输出：提供一个文件服务器，配置好ftp服务或http服务；
    			ftp服务：
    				安装程序包: vsftpd
    				文件存放路径：/var/ftp/pub
    				启动服务：service vsftpd start
    			http服务：
    				安装程序包：httpd
    				文件存放路径：/var/www/html
    				启动服务：service httpd start

    		Note: 确保防火墙服务关闭；

    	(3) 在准备好的目录中放置rpm程序包文件
    	(4) 对此目录运行createrepo命令即可

    练习：创建xen4仓库，分别通过本地及ftp或http服务输出；


bash脚本编程的for循环：
	
	过程式编程：
		顺序执行
		选择执行
		循环执行

	for的语法格式：

		for Var_Name in LIST; do
			循环体
		done

		循环要有进入条件；退出条件；
			列表不空；
			列表元素遍历结束；

		LIST的生成方式：
			(1) 直接给出：user1 user2 user3
			(2) 数值列表：
				(a) {start..end}
				(b) seq [start [step]] end
			(3) 变量引用: $*, $@
			(4) 返回列表命令
				for i in $(cut -d: -f3 /etc/passwd); do
			(5) globbing
				for i in /var/*; 

		练习：写一个脚本，完成以下功能
			(1) 假设某目录(/etc/rc.d/rc3.d/)下分别有K开头的文件和S开头的文件若干；
			(2) 显示所有以K开头的文件的文件名，并且给其附加一个stop字符串；
			(3) 显示所有以S开头的文件的文件名，并且给其附加一个start字符串；
			(4) 分别统计S开头和K开头的文件各有多少；


			#!/bin/bash
			#
			dir=/etc/rc.d/rc3.d
			declare -i kfiles=0
			declare -i sfiles=0

			for svc in $dir/K*; do
			    echo "$svc stop"
			    let kfiles++
			done

			for svc in $dir/S*; do
			    echo "$svc start"
			    let sfiles++
			done

			echo "K files: $kfiles, S files: $sfiles."		

		练习2：写一个脚本，完成以下功能
			(1) 脚本能接受用户名作为参数；
			(2) 计算此些用户的ID之和；

	for的几种特殊情况：
		(1) 省略for的列表，其会自动获取脚本参数作为列表；
		(2) C编程风格的for循环: 用到一个控制变量
			for ((变量初始值赋值;循环条件;变量的修正表达式)); do
				循环体
			done

			例如：计算100以内所有正整数之和；

				#!/bin/bash
				#
				declare -i sum=0

				for ((i=1;i<=100;i++));do
				    let sum+=$i
				done

				echo "Sum: $sum"

		(3) 循环嵌套
			外层循环体中，又有循环；

			for i in LIST1; do
				for j in LIST2; do
					循环体；
				done
				COMMAND
			done

		例子：使用ping命令探测172.16.0.0/16网络内的所有主机；

		for ((i=0;i<=254;i++)); do
			for ((j=0;j<=254;j++)); do
				ping -W 1 172.16.$i.$j
			done
		done

		练习：写一个脚本
			(1) 传递一些目录给此脚本；
			(2) 逐个显示每个目录的所有一级文件或子目录的内容类型；
			(3) 统计一共有多少个目录；且一共显示了多少个文件的内容类型；

		博客作业：yum的用法；

回顾：
	
	yum:
		yum --> repository
			yum: 配置文件
			repository: createrepo
				元数据
		COMMAND：
			install, reinstall, groupinstall, localinstall
			remove, groupremove
			repolist, grouplist, list, groupinfo, search, info
			clean, makecache
			update, groupdate
			provides, whatprovides
		配置repository:
			[repoid]
			name=
			baseurl=
				file:///, ftp://, http://
			enabled=
			gpgcheck=
			gpgkey=URL
			cost=
	for:
		C风格：
			for ((变量初始;循环条件;变量修正表达式)); do
				循环体
			done

		循环嵌套：
			for i in LIST1; do
				for j in LIST2; do
					循环体
				done
			done


文件压缩、解压缩和归档

	compress/uncompress .Z
	gzip/gunzip .gz
	bzip2/bunzip2 .bz2
	xz/unxz .xz

	zip/unzip .zip

	1、gzip/gunzip
		.gz

		语法：gzip [OPTIONS] /PATH/TO/SOMEFILE ...
			-#: 指明压缩比；1-9，默认为6，数字越大，压缩比越大；
			-d: decompress, 解压缩, 相当于gunzip；
			-c: 将压缩后的数据输出至标准输出；
				gzip -c /PATH/TO/SOMEFILE > /PATH/TO/SOMEFILE.gz
			-r: 递归至目录中对每个文件进行压缩；

		zcat /path/to/somefile.gz：无须显式解压缩查看压缩文件的内容；

	2、bzip2/bunzip2
		.bz2

		语法：bzip2 [OPTIONS] /PATH/TO/SOMEFILE...
			-#: 指明压缩比；1-9，默认为6，数字越大，压缩比越大；
			-d: decompress, 解压缩, 相当于bunzip2；
			-k: 压缩后保留原文件；

			bzcat /path/to/somefile.bz2：无须显式解压缩查看压缩文件的内容；

	3、xz/unxz
		.xz

		语法：xz [OPTIONS] /PATH/TO/SOMEFILE...
			-#: 指明压缩比；1-9，默认为6，数字越大，压缩比越大；
			-d: decompress, 解压缩, 相当于bunzip2；
			-k: 压缩后保留原文件；

			xzcat /path/to/somefile.xz：无须显式解压缩查看压缩文件的内容；	

	4、zip/unzip
		.zip

		语法：zip ZIP_FILE.zip /PATH/TO/SOMEFILE...
			zip可以多个文件压缩归档成单个文件

		unzip语法：unzip ZIP_FILE.zip

	5、归档工具
		将多个文件打包为单个文件以便于管理；默认不会执行压缩；
			tar, cpio

		语法：
			归档：tar [OPTIONS] -c -f /PATH/TO/TARFILE.tar /PATH/TO/FILE...
				归档：不会删除原文件；
			展开归档：tar -x -f /PATH/TO/TARFILE.tar [-C /PATH/TO/DIR]
			查看被归档起来的文件列表：tar -t -f /PATH/TO/TARFILE.tar	

			注意：(1) 多个选项可以合并，但-f由于要带参数，因此，应该放在最右侧；
					 -tf, -xf, -cf
				  (2) 选项的引导符-可省略
				  	tar xf , tar zf

	6、归档和压缩
		-z: gzip
			后缀名： .tar.gz
			归档并压缩：tar -zcf
			展开归档：tar -zxf 
		-j: bzip2
			后缀名： .tar.bz2
			归档并压缩：tar -jcf
			展开归档： tar -jxf
		-J: xz
			后缀后： .tar.xz
			归档并压缩： tar -Jcf
			展开归档： tar -Jxf

		注意：展开归档可以直接使用tar -xf，而无须为其指定对应的压缩工具选项；


Linux的程序包管理(3)	
	
	rpm包管理器：rpm
	rpm包管理器的前端工具：yum

		包中的文件：编译好的二进制程序、库文件；头文件、帮助文件和配置文件；

	源文件：编译成二进制程序，
		程序文件与平台就有了相关性；
		程序特性也就被确定了；
		rpm包的版本较老；

	手动编译源代码文件：
		依赖环境：编译开发工具、以及各个被依赖到的程序包的开发组件；
			编译开发工具：
				包组：
					Development tools
					Server Platform Development
					Desktop Platform Development
					Debug Tools
			被依赖的程序包的开发组件：
				两种方式：
					(1) 编译安装被依赖的程序；
					(2) 安装相关程序的名称中包含devel的子包；

	源代码文件：
		分隔保存多个文件中；文件间或许存在依赖关系，因此，编译时可能需要按特定次序进行编译；

		此时，一般会使用项目管理工具（通常也称为构建工具）对其进行管理；
			构建工具会调用合适的编译器，并根据配置文件中定义的次序对源代码文件进行编译；

			GNU make:
				配置文件：makefile

		注意：
			(1) 每个项目的程序员开发完成某版本之后，会使用autoconf为程序代码生成一个脚本文件：configure；
				功用：此脚本会收集当前系统上的开发环境中所依赖各组件的版本、特性等，并检查所依赖的环境是否能满足，最后会根据Makefile.in文件生成一个makefile文件；
			(2) 每个项目的程序员开发完成某版本之后，会使用automake为程序代码生成一个makefile模板文件，即Makefile.in；

		编译人员的编译安装过程：
			(1) 运行configure脚本；
				常使用选项指明：
					安装路径:
						--prefix=/usr/local/nginx
					启用或禁用的特性；
					依赖的程序包；
			(2) 运行make命令，完成项目构建；
			(3) 运行make install命令，完成安装；

			注意：前两步只需要普通用户权限，建议使用普通用户身份进行；最后一步根据安装路径的指定，可能会用到管理权限；


			configure脚本的应用：
				--help: 查看帮助信息；
				--prefix: 指定默认安装路径；
				--sysconfdir: 指定配置文件安装路径

				--with-CAPABILITY
				--without-CAPABILITY

				--enable-FEATURE
				--disable-FEATURE

	程序运行环境：

		二进制文件：$PATH环境变量指明的路径下，/bin, /sbin, /usr/bin, /usr/sbin, /usr/local/bin, /usr/local/sbin

			自己编译的程序文件安装路径如果不在PATH环境变量指定的程序搜索路径中：
				(1) 使用绝对路径；
				(2) 编译PATH环境变量，加入此些程序文件所在目录；
					export PATH=extra_path:$PATH

					把上面的命令保存于/etc/profile.d/*.sh文件中

		库文件：
			大多数应用程序都依赖于标准库某些共享库文件，甚至于某些应用提供的特定的库文件；

			Linux系统会在特定路径下为应用查找所依赖的库文件：/lib64, /lib, /usr/lib64, /usr/lib

			自己编译安装的程序提供的库文件有可能不在系统搜索路径中，解决办法：
				两步骤：
					(1) 编辑/etc/ld.so.conf.d/*.conf文件，添加新库文件搜索路径至此文件中，每行一个；
					(2) 执行ldconfig命令，重新生成库映射缓存ld.so.conf


			ldconfig命令：configure dynamic linker run-time bindings
				用于生成/etc/ld.so.cache

				常用选项：
					-p: 打印当前系统ld.so.cache中已经缓存的所有库文件目录及库文件映射列表；
					-v: 显示命令执行过程的详细信息；

		头文件导出方案：
			方法：
				(1) 复制所有新生成的头文件至/usr/include目录中；
				(2) 创建链接
					ln -sv /usr/local/apache/include /usr/include/httpd
					ln -sv /usr/local/apache/include/* /usr/include/

		man手册文件：
			Linux会到特定目录下查找用户需要使用命令手册
				路径：/etc/man.config配置文件中，使用MANPATH指令指向的路径；

				方法：
				(1) 在此文件新增MANPATH指令，并指向新的命令手册路径；
				(2) 在man命令执行时使用-M选项显式指定手册而查找路径即可；

		注意：如果安装的程序是一个服务类程序，rpm安装的方式通常为自动生成服务脚本文件（此文件为rpm制作者所提供），但编译安装不会有；

		注意：编译安装的程序包，尽可能把所有文件安装至一个专用路径下，卸载时删除此目录即可；

	其它程序语言开发的源码包，编译安装方式可能会有所不同；
		INSTALL, README

		例如：perl, python, ruby, java


bash脚本编程之条件测试：

	过程式编程语言
		顺序：逐条执行
		选择：只执行代码段某一部分
		循环：把某部分代码反复执行

	bash命令执行结束后有退出状态码：
		0-255：
			0：成功执行
			1-255：执行失败

		根据此前命令的退出状态来决定后续操作是否继续；获取此前命令退出状态的过程就称为条件测试；

		bash中的测试实现方式有两种：
			(1) 直接根据前一个命令的退出结果作测试；
				测试成功与否意义与命令运行的返回值可能没有直接对应意义；
			(2) 测试表达式；
				通常需要将其用命令的形式来进行表示：
					整数测试
					字符串测试
					文件测试

				转为命令格式：
					test EXPRESSION
					[ EXPRESSION ]
					[[ EXPRESSION ]]

		整数测试：
			双目操作符：需要两个操作数；
				$A -gt $B: 大于
				-ge：大于等于
				-lt：小于
				-le：小于等于
				-ne：不等于
				-eq：等于

	练习：写一个脚本
		通过命令行传递一个参数给脚本，参数为用户名
		如果用户的id号大于等于500，则显示此用户为普通用户；


	if语句的形式：
		if CONDITION; then
			分支
		fi

		if CONDITION; then
			分支1
		else
			分支2
		fi


回顾：
	压缩归档：
		gzip/gunzip/zcat
		bzip2/bunzip2/bzcat
		xz/unxz/xzcat
		zip/unzip
		
		归档：
			# tar -cf, # tar -zcf, # tar -jcf, # tar -Jcf
			# tar -xf
				-C /path/to/somedir
			# tar -tf

	源码编译安装
		前提：开发环境（Development Tools, Server Platform Development）
		编译安装（GNU make, gcc）
			标准三步骤：
				configure
				make
				make install
		安装后：
			(1) 输出二进制程序文件所在的目录至PATH环境变量；
			(2) 输出库文件所在的目录至系统搜索库的位置：/etc/ld.so.conf.d/*.conf，ldconfig
			(3) 头文件：链接方式；
			(4) man手册而：/etc/man.config中MANPATH, man -M 

		练习：编译httpd, 并启动之；

	bash条件测试：
		条件式代码运行

		测试方式：
			(1) 以前一条命令的退出状态码（布尔型值：真或假）作为测试条件；
			(2) 测试表达式：转换为命令方式
				三种形式：
					test EXPRESSION
					[ EXPRESSION ]
					[[ EXPRESSION ]]

				三种常用的测试表达式：
					整数测试、字符串测试、文件测试

		整数测试：双目
			$A -gt $B, -ge, -ne, -eq, -lt, -le


bash编程之条件测试(2)：
	
	bash中每个命令执行结束后都有退出码：
		0-255
			0: 成功
			1-255：失败

	bash脚本自身运行结束也会有退出码：
		退出取决于最后运行的语句或命令的退出码；

		自定义脚本的退出码：
			exit [0-255]

			Note: 脚本运行时，无论何时执行了exit，将结束当前bash进程；

	组合测试条件：
		条件取反：! EXPRESSION


	练习：写一个脚本
		通过命令行传递一个参数给脚本，参数为用户名
		如果用户的id号大于等于500，则显示此用户为普通用户；

		#!/bin/bash
		#
		if [ $# -lt 1 ]; then
		    echo "Plz input a parament."
		    exit 2
		fi

		if ! id $1 &> /dev/null; then
		    echo "No such user."
		    exit 1
		fi

		userid=$(id -u $1)

		if [ $userid -ge 500 ]; then
		    echo "$1 is a comman user."
		fi		

		练习：求100以内所有偶数之和；要求遍历100以内的所有正整数；
			#!/bin/bash
			#
			declare -i sum=0

			for ((i=1;i<=100;i++)); do
			    if [ $[$i%2] -eq 0 ]; then
			        let sum+=$i
			    fi
			done

			echo "Sum: $sum."


		练习：写一个脚本
			传递一个以上的参数作为用户名给脚本；
			判断这些用户的UID是否与GID相同；相同则显示之；

			#!/bin/bash
			#
			if [ $# -lt 1 ]; then
			    echo "Plz input 1 paramenter at least."
			    exit 1
			fi

			for user in $@; do
			    if ! id $user &> /dev/null; then
			        echo "No such user."
			        exit 2
			    fi

			    if [ $(id -u $user) -eq $(id -g $user) ]; then
			        echo -n "UID same as GID: "
			        echo "$user"
			    fi
			done	

		练习：写一个脚本
			(1) 添加10用户user1-user10；密码同用户名；
			(2) 用户不存在时才添加；存在时则跳过；
			#!/bin/bash
			#
			declare -i usercount=0

			for i in {1..10}; do
			    if ! id user$i &> /dev/null; then
			        useradd user$i
			        echo user$i | passwd --stdin user$i &> /dev/null
			        let usercount++
			        echo "add user user$i finished."
			    fi
			done

			echo "Total user added: $usercount."

		练习：写一脚本
			(1) 用ping命令测试172.16.250.20-172.16.250.100以内有哪些主机在线，将在线的显示出来；

			#!/bin/bash
			#
			for ((i=1;i<=100;i++)); do
			    if ping -w 1 -c 1 172.16.250.$i &> /dev/null; then
			        echo "172.16.250.$i is up."
			    fi
			done

	双分支的if语句：

		if CONDITION-is-TRUE; then
			分支1
		else
			分支2
		fi

		练习：写一脚本
			(1) 用ping命令测试172.16.100.20-172.16.100.100以内有哪些主机在线，将在线的显示出来；

			#!/bin/bash
			#
			for ((i=1;i<=20;i++)); do
			    if ping -w 1 -c 1 172.16.100.$i &> /dev/null; then
			        echo -e "\033[32m172.16.100.$i\033[0m is up."
			    else
			        echo -e "\033[31m172.16.100.$i\033[0m is down."
			    fi
			done

		练习：写一个脚本，遍历100以内所有正整数，并分别求出所有偶数与所有奇数之和；

			#!/bin/bash
			#
			declare -i evensum=0
			declare -i oddsum=0

			for ((i=1;i<=100;i++)); do
			    if [ $[$i%2] -eq 1 ]; then
			        let oddsum+=$i
			    else
			        let evensum+=$i
			    fi
			done

			echo "EvenSum: $evensum, OddSum: $oddsum."

		练习：写一个脚本，添加10个用户
			(1) 如果用户存在，则说明其已经存在；
			(2) 如果用户不存在，则添加之，并说明添加OK；
			(3) 最后显示本次共添加了多少用户；

				#!/bin/bash
				#
				declare -i usercount=0

				for i in {1..10}; do
				    if id user$i &> /dev/null; then
				        echo "user$i exists."
				    else
				        useradd user$i
				        echo user$i | passwd --stdin user$i &> /dev/null
				        let usercount++
				        echo "ADD user$i finished."
				    fi
				done

				echo "Add users: $usercount."


		练习：写一个脚本，传递n个整数给脚本，分别返回其最大值和最小值；

			#!/bin/bash
			#
			declare -i max=$1
			declare -i min=$1

			if [ $# -lt 1 ]; then
			    echo "1 paramter."
			    exit 1
			fi

			for number in $*; do
			    if [ $number -gt $max ]; then
			        max=$number
			    fi

			    if [ $number -lt $min ]; then
			        min=$number
			    fi
			done

			echo "Max number is $max." 
			echo "Min number is $min."

		练习：打印九九乘法表；

			#!/bin/bash
			#
			for i in {1..9}; do
			    for j in {1..9}; do
			        if [ $i -ge $j ]; then
			            echo -n "${j}X${i}=$[$i*$j] "
			        fi
			    done
			    echo
			done		


	字符串测试：$str1, $str2
		双目：
			"$str1" > "$str2": 测试str1是否大于str2，是则为真，不是则为假；
			<：是否小于
			==: 是否等于；
			!=: 是否不等于；

		单目：
			-z "$str1": 测试str1字符串是否为空，空则为真，不空则为假；
			-n "$str1": 测试str1字符串是否不空，不空则为真，空则为假；

		模式匹配测试：
			"$str1"=~PATTERN:
				如果str1字符串能够被后面的模式所匹配则为真，否则为假；

			练习：写一个脚本，判断当前系统上所有用户的shell是否为可登录shell（即用户的shell不是/sbin/nologin）；分别这两类用户的个数；
				通过字符串比较来实现；

				#!/bin/bash
				#
				declare -i loginshell=0
				declare -i nologin=0

				for shell in $(cut -d: -f7 /etc/passwd); do
				    if [ "$shell" == '/sbin/nologin' ]; then
				        let nologin++
				    else
				        let loginshell++
				    fi
				done

				echo "Login Shell Users: $loginshell, No login Shell Users: $nologin."

			练习：写一个脚本
				(1) 获取当前主机的主机名，保存于hostname变量中；
				(2) 判断此变量的值是否为localhost，如果是，则将当前主机名修改为www.magedu.com；
				(3) 否则，则显示当前主机名；
					#!/bin/bash
					#
					host=$(hostname)

					if [ "$host" == 'localhost' ]; then
					    echo 'www.magedu.com' > /proc/sys/kernel/hostname
					    echo "The hostname is: $(hostname)."
					else
					    echo "The hostname is: $host."
					fi

			练习：写一个脚本，完成如下功能
				(1) 传递一个磁盘设备文件路径给脚本，判断此设备是否存在；
				(2) 如果存在，则显示此设备上的所有分区信息；

				#!/bin/bash
				#
				if ! [[ "$1" =~ ^/dev/[sh]d[a-z]$ ]]; then
				   echo "Not a device file."
				   exit 1
				fi

				if fdisk -l /dev/[hs]d[a-z] | grep "^Disk" | grep "$1" &> /dev/null; then
				    fdisk -l $1
				else
				    echo "No such disk."
				fi

	多分支的if语句：
		语法结构：

			if CONDITION1-is-TRUE; then
				分支1
			elif CONDITION2-is-TRUE; then
				分支2
			elif CONDITION3-is-TRUE; then
				分支3
			...
			...
			else
				分支n
			fi

		Note: 
			(1) 测试自上而下逐条件进行；
			(2) 遇到符合条件的，即遇到某为真的测试条件后，将不再进行后续的条件测试；

		示例：写一个脚本，完成如下功能
			脚本能够接受一个参数；
			(1) 如果参数1为quit，则显示退出脚本，并执行正常退出；
			(2) 如果参数1为yes，则显示继续执行脚本；
			(3) 否则，参数1为其它任意值，均执行非正常退出；

			#!/bin/bash
			#
			if [[ "$1" =~ ^QUIT|Quit|quit$ ]]; then
			    echo "Finished."
			    exit 0
			elif [ "$1" == 'yes' ]; then
			    echo "Continue."
			else
			    echo "Unknown Argument."
			    exit 1
			fi		

		练习：写一个脚本，完成如下功能
			传递一个参数给脚本，此参数为gzip、bzip2或者xz三者之一；
			(1) 如果参数1的值为gzip，则使用tar和gzip归档压缩/etc目录至/backups目录中，并命名为/backups/etc-20150413.tar.gz；
			(2) 如果参数1的值为bzip2，则使用tar和bzip2归档压缩/etc目录至/backups目录中，并命名为/backups/etc-20150413.tar.bz2；
			(3) 如果参数1的值为xz，则使用tar和xz归档压缩/etc目录至/backups目录中，并命名为/backups/etc-20150413.tar.xz；
			(4) 其它任意值，则显示错误压缩工具，并执行非正常退出；


		
回顾：bash编程条件测试
	if语句的结构：
		单分支：
			if CONDITION-is-TRUE; then
				分支
			fi
		双分支：
			if CONDITION-is-TRUE; then
				分支1
			else
				分支2
			fi
		多分支：
			if CONDITION1-is-TRUE; then
				分支1
			elif CONDITION2-is-TRUE; then
				分支2
			...
			...
			else
				分支n
			fi
	测试形式:
		(1) 命令的执行状态结果，即命令成功与否；
			if COMMAND &> /dev/null; then
		(2) 条件表达式
			命令形式：
				(a) test EXPRESSION
					if test EXPRESSION; then
				(b) [ EXPRESSION ] 
					if [ EXPRESSION ]; then
			关键字形式：
				(c) [[ EXPRESSION ]]
					if [[ EXPRESSION ]]; then
	测试方式:
		整数测试：
			-ge, -gt, -le, -lt, -ne, -eq
		字符串测试：
			双目：>, <, ==, !=, =~
			单目：-z, -n
		文件测试:


Linux进程查看与管理

	OS的基本功能：文件系统、网络功能、进程管理、内存管理、驱动程序、安全功能

	程序=指令+数据

	CPU：
		特权指令
		普通指令

	程序执行环境：
		内核模式：运行内核级指令
		用户模式：运行普通指令

		应用程序：
			运行普通指令：直接运行于CPU
			运行特权指令：通过system call

	内存：8bits, 1byte
		32bits, 2^32, 0-2^32-1, 2^10*2^10*2^10*2^2 bytes = 2^10*2^10*2^2 kilo bytes = 2^10*2^2 MB = 4GB

	ROM+RAM
		ROM, RAM

	地址空间：
		物理地址空间
		线性地址空间

	IPC: Inter Process Communication
		同一主机：
			signal
			semerphor
			shm (shared memory)

		不同主机：
			rpc: remote procedure call
			socket: 

	进程调度：

		多任务：多进程同时运行
			抢占式多任务

		进程分类：
			CPU bound: CPU密集型
			I/O bound: IO密集型

		进程优先级：
			140：0-139
				1-99：实时优先级，数字越大优先级越高
				100-139：数字越小，优先级越高；
					静态优先级
					动态优先级

		算法时间复杂度：Big O
				O(1)
				O(logn)
				O(n)
				O(n^2)
				O(2^n)

	进程创建：
		请求发出者：进程
			进程：fork(), clone()

			COW: Copy On Writing
				写时复制

	进程的状态：
		运行态：running
		睡眠态：sleeping
			可中断睡眠：interruptible
			不可中断睡眠: uninterruptible
				被IO阻塞的进程
		就绪态：runnable
		停止态：stopped，不可被调度并运行；
		僵死态：zombie

	进程管理：
		task struct: 用于保存每个进程元数据信息
			例如：pid, ppid, memory, thread, files

		task list: 用一种称作“链表”的数据结构来保存每个进程的task struct

		进程切换：context switch
			保存现场：
			恢复现场：

	OS: 提供虚拟的计算机，进而能够将有限资源借助于“保护”机制分配多个同时运行的程序，即“进程”使用，从而实现了所谓的多任务；

	进程：
		线程：tread
			共享进程的资源，如打开文件等；
			更轻量的、可被单独调度的运行单元；

		LWP：Light Weight Process

	Linux进程查看及管理工具：top, pstree, ps, pidof, pgrep, pkill, htop, glances, pmap, vmstat, dstat, iostat, sar, kill, job, bg, fg

		Linux系统上除init以外的所有子进程，都是由其父进程fork()自身而来，遵循COW机制；进程展现为“进程树”; 

		pstree命令：
			进程树查看；
			-p: 显示各进程的PID；

		ps: process state

			Linux运行中的内核的相关信息是通过/proc伪文件系统输出的；各进程都有一个以其PID命名的子目录，每个子目录中有许多文件存储了进程的相关状态信息；

			显示的是ps命令执行时，系统上当前进程状态信息的快照；所以，为静态结果；

			支持众多选项：
				BSD风格
				SysV风格

			根据进程启动时是否是通过终端上的用户接口交互式启动的，进程可分为两类：
				与终端相关的进程: a
				与终端无关的进程: x

				以用户为中心组织进程状态信息显示：u

			常用选项组合1：axu
				USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND

					VSZ: Virtual memory Size
						线性地址空间占用的空间大小；
					RSS：常用驻内存集；指不可以被交换至swap空间的数据占据空间大小；

					STAT：进程状态
						R: running，运行状态；
						S：interruptible sleeping，可中断睡眠
						D：uniterruptible sleeping, 不可中断睡眠
						T: stopped
						Z: zombie

						s: session leader
						+: 前台进程，占据着某终端
						l: 多线程进程
						<: 高优先级进程
						N: 低优先级进程

					START: 启动时间
					TIME: 占据CPU累积时长
					COMMAND: 启动当前进程或线程的命令行程序，[]表示为内核线程；

			常用选项组合2: -ef
				-e: 显示所有进程；
				-f: 显示丰富格式信息

			常用选项组合3：-eFH
				-F: 显示额外信息
				-H: 以层级形式显示进程间关系；

			自定义需要显示的信息：axo
				ps axo pid,command,psr,pri,ni
					psr: 当前进程运行的CPU编号；
					pri: 当前进程的优先级；
					ni: 当前进程的nice值；
						-20, 19

		pgrep: 
			语法格式：pgrep [OPTIONS] "PATTERN"
				-U UID：仅显示以指定用户身份运行的进程；
				-G GID
				-l: 显示PID和进程名；

		pidof: 
			pidof PROGRAM
				PROGRAM: 给定命令行程序

		top命令：
			有许多交互式的子命令；
				P：以占据的CPU百分比大小排序；
				M：以占据Memory空间大小排序；
				T：CPU累积占用时间排序；

				l: 是否显示系统负载行；
					队列长度的合理区间：CPU颗数*0.7
				t: 是否显示进程摘要信息及CPU负载状态；
					Cpu(s):  0.0%us,  0.0%sy,  0.0%ni,100.0%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st
						us: user space
						sy: system (kernel space)
						ni: nice
						id: idle
						wa: wait io
						hi: hardware interrupt
						si: software interrupt
						st: stolen, 被虚拟机“偷走”的百分比
				1：平均或单独显示CPU的负载状态；
				m: 是否显示内存相关的状态信息；

				q: 退出命令
				s: 修改延迟时长
				k: 终止指定进程

			top命令的选项：
				-b: batch，批次显示
				-n #: 显示的批次数量
				-d #: 指明延迟时长

		uptime命令: 显示当前系统时间，运行时长，登录用户数及系统平均负载；

	命令总结：pstree, ps, pgrep, top, uptime, pidof
	
	
回顾：
  进程管理
    task struct: 每个进程的元数据信息，例如进程的pid，ppid, thread, files
    task list: 任务列表，链表
    
    进程的线性地址空间：
      Text Segment
      Data Segment
      BSS Segment
      Heap      
      Stack
      
    进程状态：
      就绪态，运行态，睡眠（可中断，不可中断），停止态，僵死态
      
    进程优先级：
      实时优先级
      静态优先级：
	100-139
      动态优先级
    
  进程查看基本工具：pstree, ps, top, pidof, pgrep, uptime
    ps: axu, -ef, -eFH, axo
    top: P,M,T,l,t,m,s,q,k
    
Linux进程查看与管理(2)
  
    htop: 
      交互式命令：
	u: 过滤仅显示选定用户的进程；
	s: 跟踪选定的进程所发起的系统调用；
	l: 显示选定进程所打开的文件；
	t: 显示进程的层次结构；
	a: 设定进程的cpu亲缘性；（将选定的进程绑定在指定的CPU上）
	
      选项：
	-d #: 延迟时长
	-u USERNAME: 仅显示指定用户的进程；
	-s COLUMN: 根据指定的字段进行排序；
	
    vmstat命令：
    
      用法：vmsate [delay [count]]
      
      procs:
	r: 等待运行的进程的个数；（队列长度）
	b：处理不可中断睡眠状态的进程的个数；（即IO阻塞队列长度）
      
      memory：
	swpd: 交换内存使用量；
	free: 空间的物理内存量；
	buffer: 用于buffer的内存总量；
	cache: 用于cache的内存总量；
      
      swap：
	si: 数据进入swap中的速率(kb/s)
	so: 数据离开swap的速率(kb/s)
      
      io
	bi: 从块设备读入数据到系统的速率(kb/s)
	bo: 保存数据至块设备的速率(kb/s)
      
      system
	in: 中断速率
	cs: 进程切换的速率
      
      cpu 
	us: 
	sy:
	id:
	wa:
	st:
	
    选项：
      -s：显示内在的状态统计数据
      
    /proc/#接口：
	
    pmap: 查看指定进程的内存映射关系；
      pmap [OPTIONS] pid...
	-x: 显示扩展信息
	
      cat /proc/#/maps
      
    glances: 
      glances [-bdehmnrsvyz1] [-B bind] [-c server] [-C conffile] [-p port] [-P password] [--password] [-t refresh] [-f file] [-o output]
      
      常用选项：
	-b: 以Byte/s为单位显示网卡设备数据交换速率；
	-d: 关闭磁盘I/O功能模块；
	-f /PATH/TO/SOMEFILE：设置输出文件的位置及格式；
	-o {HTML|CSV}:
	-m: 关闭mount功能模块
	-n: 关闭网络功能模块
	-r: 关闭进程列表功能模块
	-t #: 指定延迟时长，默认为3秒；
	-1：单独显示每颗CPU相关负载数据信息；
	
      glances支持远程模式：
	  即可以以C/S模式工作：
	      Server: 以监听模式启动glances；
	      Client: 以远程模式启动glances，远程连入指定服务器，并Server上的相关性能数据；
	      
	  服务模式：
	    glances -s -B IPADDR
	      -B: 用于指明监听的本地地址；
	      
	  客户端模式：
	    glances -c IPADDR
	      -c: 用于连入的服务器的地址；
	    
    dstat: 整合了vmstat, iostat, netstat and ifstat四款工具的功能；
      dstat [-afv] [options..] [delay [count]]
      
		-c: 显示cpu性能指标相关的统计数据；
		-d: 显示disk相关的速率数据；
		-g: 显示page相关的速率数据；
		-i: 显示interrupt相关的速率数据；
		-l: 显示load average相关的统计数据；
		-m: 显示memory相关的统计数据；
		-n: 显示网络收发数据的速率；
		-p: 显示进程相关的统计数据，
		-r: io请求的速率；
		-s: 显示swap的相关数据
		-y: 显示系统相关的数据，包括中断和进程切换；
		
		--top-cpu：显示最占用CPU的进程；
		--top-bio：显示最消耗block io的进程；
		--top-io：最占用io的进程；
		--top-mem：显示最占用内存的进程；
		
		--ipc: 显示进程间通信相关的速率数据；
		--raw: 显示raw套接的相关的数据；
		--tcp: 显示tcp套接字的相关数据；
		--udp: 显示udp套接字的相关数据；
		--unix: 显示unix sock接口相关的统计数据；
		--socket: 
		
		-a: -cdngy
	
      IPC: 进程间通信
	  常见形式：
	    message queue
	    semerphore
	    shared memory
	    signal
	    
    signal: 传递给进程的短小信息
		Linux主机支持的进程间可用到的信息：
		(1) kill -l
		(2) man 7 signal
		
		向进程发信号：
			kill [-SIGNAL] PID 
			默认的信号为SIGTERM；
			
			信号表示方式：
			(1) 完整名称，例如SIGINT
			(2) 简写名称，例如INT
			(3) 数据代称，例如2
			常用信号：
			SIGHUP: 1, 通知进程重读其配置文件以让新的配置生效，但不用重新启动进程；
			SIGINT：2, 打断正在运行中的进程，相当于键盘组合键Ctrl+c
			SIGKILL：9, 强行中止正在运行中的进程
			SIGTERM： 15, 安全中止正在运行中的进程
			SIGSTOP： 19, 暂停进程
			SIGCONT： 18, 继续运行指定进程
			
	kill相似的一组进程：
	    killall [-SIGNAL] PROGRAM
	    
    命令总结：htop, vmstat, pmap, glances, dstat, kill, killall
    
    作业管理：
	前台作业：通过终端启动，并且在停止之前也会一直占据终端；
	后台作业：作业启动之时与终端无关，或者是在前台启动，但启动后转为与终端无关模式运行；
	
	如何让作业运行于后台？
	    1、对于已经启动并处于运行中的作业：
	      Ctrl+z
	      
	      Note: 作业被送往后台后，默认处于stopped状态；
	    2、对于尚未启动的作业：
	      COMMAND &
	      
	    注意: 此两类方式相关作业，仍然与终端相关；这意味着，终端终止，将会导致与此终端相关的所有作业被终止；
	    
	    剥离进程与终端的关系：
	      # nohup COMMAND &
	   
	作业查看：
	
	  jobs命令
	    作业号、作业状态、启动命令行程序
	    
	  作业控制命令：
	      fg [[%]job_num]：把指定的作业调回前台；
	      bg [[%]job_num]：把调往后台的指定的作业启动起来，让其后台默默运行；但此作业必须支持运行于后台；
	      kill [%job_num]：终止指定的作业；
	      
	进程优先级调整：
	    静态优先级：
		通过指定进程的nice值来调整其优先级；用户 空间运行的进程一般都有其nice值；
		nice值： -20, 19
		优先级：  100, 139
		
	    默认启动进程时，其nice值为0, 其优先级为120；
	    
	    (1) 对于尚未启动的进程：
		# nice -n N COMMAND
		
	    (2) 对于已经启动并处于运行中的进程：
		# renice -n N PID 
		
	    注意：普通用户仅能够调大nice，调低优先级；
	    
	尚未讲到的命令：sar, iostat, ifstat, tsar；
	
    命令总结：jobs, fg, bg, nice, renice
    
    博客作业：进程管理工具htop/glances/dstat的使用; 
    

bash脚本编程之条件测试(3)

	测试表达式：
		整数测试：-gt, -ge, -lt, -le, -ne, -eq
		字符串测试：>, <, ==, !=, =~, -z, -n
		
		文件测试：$file
			存在性及类型测试：
				-e $file: 文件是否存在，存在为真，否则为假；
					-a $file: 同上；
				-f $file: 文件是否存在且为普通文件，是则为真，不是则假； 
				-d $file：路径是否存在且为目录文件；
				-h|-L $file: 路径是否为符号链接文件；
				-b $file: 路径是否存在且为块设备文件；
				-c $file: 路径是否存在且为字符设备文件；
				-S $file: 路径是否存在且为套接字文件；
				-p $file: 路径是否存在且为管道文件；
			
			文件权限判断：
				-r $file: 文件是否存在且对当前用户可读；
				-w $file: 文件是否存在且对当前用户可写；
				-x $file: 文件是否存在且对当前用户可执行；
				
				-u $file: 文件是否存在且拥有SUID权限；
				-g $file: 文件是否存在且拥有SGID权限；
				-k $file：文件是否存在且且拥有sticky权限；
				
				-O $file: 当前用户是否路径指向的文件的属主；
				-G $file：当前用户是否属于文件的属组；
				
			文件时间戳相关：
				-N $file：文件自从最近一次的读访问之后，是否又被修改过；
				
				$f1 -nt $f2: f1是否新于f2；
				$f1 -ot $f2: f1是否旧于f2；
				$f1 -ef $f2: f1和f2是否为同一个文件的两个硬链接；
				
		示例：写一个脚本，接受一个路径参数；
			(1) 存在，则显示有此文件；
			(2) 否则，则显示无此文件；
			
		练习：写一个脚本，接受一个路径参数：
			(1) 如果为普通文件，则说明其可被正常访问；
			(2) 如果是目录文件，则说明可对其使用cd命令；
			(3) 如果为符号链接文件，则说明是个访问路径；
			(4) 其它为无法判断；
			
	组合条件测试：
		在条件之间添加逻辑操作符：
			或：-o， [ EXP1 -o EXP2 ] 
			与：-a,  [ EXP1 -a EXP2 ]
			非：!, [ ! EXPRESSION ]
			
		示例：写一个脚本，取得当前主机的主机名，判断
			(1) 如果主机名为空或为localhost，或为"(none)"，则将其命名为mail.magedu.com；
			(2) 否则，显示现有的主机名即可；
			
			#!/bin/bash
			#
			hname=$(hostname)

			if [ -z "$hname" -o "$hname" == "(none)" -o "$hname" == "localhost" ]; then
				hostname mail.magedu.com
			else
				echo "The hostname is: $hname."
			fi	
			
		练习：写一脚本，接受一个用户名为参数；
			(1) 如果用户的id号为0,则显示其为管理员；
			(2) 如果用户的id号大于0且小于500, 则显示其为系统用户；
			(3) 否则，则显示其为普通用户；
			
			#!/bin/bash
			#
			userid=$(id -u $1)

			if [ $userid -eq 0 ]; then
				echo "admin"
			elif [ $userid -gt 0 -a $userid -lt 500 ]; then
				echo "sys user, id is $userid"
			else
				echo "Common user, id is $userid"
			fi
			
			
		练习：写一个脚本，传递一个用户名参数给脚本；
			(1) 如果用户的id号大于等于500，且其默认shell为以sh结尾的字符串，则显示“a user can log system.”类的字符串；
			(2) 否则，则显示无法登录系统； 
			
			#!/bin/bash
			#
			#usershell=$(grep "^$1\>" /etc/passwd | cut -d: -f7)
			grep "^$1\>.*sh$" /etc/passwd
			retval=$?

			if [ $(id -u $1) -ge 500 -a $retval -eq 0 ]; then
				echo "a user can log system."
			else
				echo "a user cannot log."
			fi
			
		练习：写一个脚本，完成如下任务 ：
			(1) 按顺序分别复制/var/log目录下的每个直接文件或子目录至/tmp/test1-testn目录中；
			(2) 复制目录时，才使用cp -r命令；
			(3) 复制文件时使用cp命令；
			(4) 复制链接文件时使用cp -d命令；
			(5) 余下的所有类型，使用cp -a命令；
			
		
回顾：
	进程查看或管理工具：htop, vmstat, glances, dstat
	bash脚本编程：文件测试，组合条件测试
		文件测试：
			存在性：-e, -a, -f, -d, -h, -L, -b, -c, -S, -p
			权限：-r, -w, -x, -U, -G, -u, -g, -k
			时间戳：-N
			
			双目操作符：-nt, -ot, -ef
			
		组合测试条件：（连接测试表达式）
			与：-a
				所有条件必须同时为“真”，结果才为“真”；
			或：-o
				只要有一条件为“真”，则结果即为“真”；
			非：!
				取反
				
CentOS 系统启动流程：
	
	内核的功能：进程管理、文件系统、驱动程序、网络子系统、安全功能、内存管理
	
	内核设计流派：
		单内核体系：
			Linux，模拟化设计机制
				核心功能+各种模块：
					模块可动态装载和卸载；
		微内核体系：
			windows
			Solaris
			Minix 
			Hurd 
			
			设计思想：内核核心仅保留最基本功能，而把其它功能做成子系统；各子系统之间依靠通信完成基本功能；
			
	CentOS系统启动流程：
		
		POST：CPU，ROM 
			周边硬件检测
			CMOS：BIOS
			
		BIOS：boot sequence
			按次序查找各引导设备，第一个有引导程序的设备即为启动系统用到的设备；
				1st
				2nd
				3rd
				
		MBR：Master Boot Record
			512bytes:
				446bytes: bootloader（程序，OS安装时生成）；
				64bytes: 分区表
				2bytes：55AA
				
		bootloader：加载选定的操作系统的内核至RAM中，并展开至固定的位置；多系统共存的场景中，还会提供一个选择菜单；
		
			LILO： LInux LOader
			
			GRUB: GRand Unified Bootloader
				MBR: 1st stage
				/boot/grub/: 2nd stage
				
				GRUB 0.X: GRUB Legacy
					CentOS 5, CentOS 6
				GRUB 1.X：GRUB 2
					CentOS 7
					
		Kernel: 
			自身初始化：
				探测可识别的所有硬件；
				装载硬件设备的驱动程序（ramdisk）；
					ramdisk: 加载至内存中，此段内存空间被虚拟成了块设备；
						用于提供硬盘驱动程序；系统安装时临时生成的；
						ramdisk被内核识别为“根文件系统”，即rootfs，常被称作“临时根”；
				以只读方式装载“真正根文件系统”；
				启动用户空间的第一个应用程序：/sbin/init
				
			init: 
				CentOS 5: SysV init
					特点：启动用户空间的服务程序，通常通过脚本进行；有依赖关系的服务将被串行启动；
					配置文件：/etc/inittab
				CentOS 6: Upstart
					特点：守护进程间的通信依赖于D-Bus进行，因此，可基本实现类似并行启动；
					配置文件：/etc/inittab, /etc/init/*.conf
				CentOS 7: Systemd
					特点：服务只有在第一次被访问到时才会真正启动起来；
					配置文件：/usr/lib/systemd/
					
		/sbin/init
			
			Linux系统运行级别：为系统维护的目的而设定，途径是设定启动或关闭服务实现；
				0-6： 7个级别
					0：关闭所有服务；关机
					1：维护模式，单用户模式，sigle模式；此级别可允许root用户直接登录而无须认证；
					2：维护模式，多用户模式，需要用户认让，会启动网络功能，但不支持使用NFS；
					3：正常级别，完全多用户模式，文本界面；
					4：预留级别
					5：正常级别，完全多用户模式，图形界面；
					6：关闭所有服务；重启 
					
				默认级别：3,5
					
				切换级别：
					init [0-6]
						init 0
						init 6
						
				查看级别：
					runlevel命令
					who -r
				
			配置文件：/etc/inittab(CentOS 5)配置文件格式
				每一行定义一个由init执行的action，以及对应的程序；
					action用于定义程序什么时候被运行；
				格式：
					id:runlevel:action:process
					
				例如：设定默认运行级别
					id:3:initdefault:
					
				例如：定义完成系统初始化的脚本
					si::sysinit:/etc/rc.d/rc.sysinit
															
					初始化用户空间环境；此脚本会执行许多系统初始化任务；
					
				例如：启动对应级别下设定为要启动的服务，关闭那些设定为要停止的服务；
					l1:1:wait:/etc/rc.d/rc 1
					l2:2:wait:/etc/rc.d/rc 2
					l3:3:wait:/etc/rc.d/rc 3
						意味着：通过/etc/rc.d/rc1.d/下所有链接文件来决定如何启动或关闭服务；
							所有以S开头的，都被传递start参数以启动； 所有以K开头的，都被传递stop参数以停止； 
							
				/etc/init.d/SVC_SCRIPTS, 此些脚本遵循LSB服务脚本的定义规范，都接受至少四个最基本的参数，{start|stop|status|restart}；
					start
					stop
					restart
					status: 查看服务运行状态；
					
					脚本在指定级别为启动还是停止的控制方法：
						1、这些脚本开头：	
							# chkconfig: S_LEVELS S_PRIO K_PRIO
							# description: 
							
						2、第二方法：
							### BEGIN INIT INFO
							# Provides: crond crontab
							# Required-Start: $local_fs $syslog
							# Required-Stop: $local_fs $syslog
							# Default-Start:  2345
							# Default-Stop: 90
							# Short-Description: run cron daemon
							# Description: cron is a standard UNIX program that runs user-specified 
							#              programs at periodic scheduled times. vixie cron adds a 
							#              number of features to the basic UNIX cron, including better 
							#              security and more powerful configuration options.
							### END INIT INFO
						
							
						
					
					此些脚本可直接被调用：
						/etc/init.d/SVC_SCRIPTS {start|stop|status|restart}
					也可以使用service命令调用：
						service SVC_SCRIPTS {start|stop|status|restart}
						
					此些服务也可以开机（或切换至指定级别时）时被自动启动或停止：
						方法：
							/etc/rc.d/rc脚本，以及每个级别对应的级别目录下的“符号链接”来进行（/etc/rc.d/rcN.d）；
								S##SVC_SCRIPTS
								K##SVC_SCRIPTS
								
								##：两位数字，表示优先级别；
									X --> Y
										先启Y，再启X；
										先停X，再停Y；
										
										启动时：被依赖的服务数字较小；
										停止时：被依赖的服务数字较大；
								
							例如：服务mysvc，脚本为/etc/init.d/mysvc
								对应于级别3,开机可自动被启动：/etc/rc.d/rc3.d/S77mysvc
								
								for svc in /etc/rc.d/rc3.d/S*; do
									$svc start
								done
								
								for svc in /etc/rc.d/rc3.d/K*; do
									$svc stop
								done
								
							注意：此些符号链接的创建可通过chkconfig命令来实现
								chkconfig [--level LEVELS] SVC_SCRIPTS on|off
									--level选项明确指定的级别为on或off, 余下的级别保存原有；
									默认为2345级别；
									
								chkconfig --list [SVC_SCRIPTS]：
									查看服务在对应级别的状态；
									
								chkconfig --add|--del SVC_SCRIPTS
									--add: 为某存放在/etc/init.d的服务在对应的/etc/rc.d/rc0-6.d目录添加符号链接；
									--del: 把指定SVC_SCRIPTS的在7个级别符号链接统统删除；
									
							注意：有一个特殊的链接，以/etc/rc.d/rc3.d为例：
								S99local, 指向/etc/rc.local脚本；
								
								功能：那些不便定义为服务脚本，设定开机自动运行时，可直接把命令写在此脚本中以实现开机运行；
									
				例如：启动虚拟终端
					一般启动6个虚拟终端：
						tty1:2345:respawn:/sbin/mingetty tty1
						tty2:2345:respawn:/sbin/mingetty tty2
						tty3:2345:respawn:/sbin/mingetty tty3
						
					每个虚拟终端启动之后，会立即通过此终端附加一个应用程序————login
						
					如果默认级别为5,还会启动一个图形虚拟终端；会附加X应用程序；
					
			/etc/rc.d/rc.sysinit脚本的功能：
				(1) 根据配置文件中的设定来设定主机名（读取/etc/sysconfig/network文件中的HOSTNAME进行）；
				(2) 打印文本欢迎信息； 
				(3) 激活SELinux和udev；
				(4) 挂载所有定义在/etc/fstab文件中的文件系统；
				(5) 激活swap设备；
				(6) 检测根文件系统，并实现以读写方式重新挂载； 
				(7) 设置系统时钟； 
				(8) 根据/etc/sysctl.conf文件设定内核参数的值； 
				(9) 激活LVM和RAID设备；
				(10) 加载额外的设备驱动程序；
				(11) 清理操作； 
					
	系统启动流程：POST --> BIOS(boot sequence) --> MBR (bootloader) --> kernel(ramdisk) --> /sbin/init
				设定默认运行级别 --> 使用/etc/rc.d/rc.sysinit脚本进行系统初始化 --> 分别关闭和启动对应级别的所有服务 --> 启动字符终端 --> 启动图形终端(如果默认级别为5）--> 显示登录提示； 
				
		注意：
			(1) CentOS 6的init程序为upstart，其配置文件为/etc/init/*.conf；此些配置遵循upstart语法格式进行编程； 
			(2) CentOS 6的服务控制事实上大多数并没有使用upstart脚本来控制，而依然使用的是SysV风格的脚本；
			

	GRUB Legacy: 
		grub组成部分: 
			stage1: MBR 
			stage1_5: MBR随后的扇区中存放，用于与stage2所在分区的文件系统进行交互；
			sttage2: 磁盘分区上(/boot/grub)
			
		功能：
			1、加载用户选择要启动的系统的内核；
				允许用户向内核传递参数；
			2、提供一个菜单，支持交互式应用；
				grub有内建命令；调用接口有两个：
					(1) 菜单，支持编辑；e
					(2) 交互式，c
				注意：菜单界面可被隐藏
			3、为编辑菜单提供保护机制
				编辑保护：
					认证后方能进行编辑
				启用内核保护：
					认证后方能使用选定的内核
					
		编辑界面：e, b
			root: 指明内核文件所在分区；
			kernel: 指明内核文件路径，及传递给内核的参数；
			initrd: 指明辅助内核完成系统启动的ramdisk文件；
			
		如何识别分区：
			(hd#,#): 
				第一个#号：表示磁盘设备；
				第二个#号：表示磁盘分区；
					(hd0,0)
					
					例如：(hd0,0)/grub/grub.conf
					
						root (hd0,0)：指明根设备；
						/grub/grub.conf
						
					所有的分区都识别为hd格式；
					
				系统启动后：/boot/grub/grub.conf
					问题是：系统启动之前，grub访问此文件的路径是什么？
						如果boot与rootfs不在同一分区：
							/grub/grub.conf
						如果boot与rootfs在同一分区，boot没有使用单独的分区：
							/boot/grub/grub.conf
							
		grub的命令行接口：c
		
回顾：
	CentOS启动流程：
		POST --> BIOS (boot sequence) --> bootloader (MBR) --> kernel (ramdisk) --> /sbin/init
			CentOS 5： sysv init, /etc/inittab
			CentOS 6：upstart, /etc/init/*.conf
			CentOS 7: systemd, /usr/lib/systemd
		设定默认运行级别-->基于/etc/rc.d/rc.sysinit完成系统初始化-->关闭和启动对应级别下的服务-->启动字符终端-->启动图形终端(如果为级别5）-->打印登录提示符
	GRUB：
		bootloader
		GRUB Legacy, GRUB 2
		
		MBR: stage1, MBR之后的扇区中的：stage1_5，磁盘分区上: stage2
		
		识别硬盘：(hd#,#)，例如(hd0,0)
			
CentOS启动流程（2）

	GRUB
	
		GRUB配置文件：/boot/grub/grub.conf
			default: 设定默认启动的内核或操作系统；
			timeout: 超时时长；单位是秒；
			splashimage: grub菜单的背景图片；
				图片：xpm格式, 压缩为gzip, 14bits颜色，640X480；
				提示：gimp图片编辑器
			hiddenmenu: 隐藏选择菜单
			title: 定义一个操作系统或系统内核；
				title Description
					root： 指明引导当前操作系统或内核文件所在的分区；
					kernel：内核文件路径、根文件系统所在设备，以及传递给内核的参数；
					initrd: 指明用于辅助内核完成系统启动的ramdisk文件路径
						CentOS 5: initrd-VERSION.img
						CentOS 6: initramfs-VERSION.img
							ramfs: 可避免ramdisk模拟为块设备时，其数据会内核再次在内存缓存；
							
		GRUB的命令行接口：
			help: 获取帮助
			find: 文件查找，通常用于定位文件，方法find (hd#,#)/
			root
			kernel
			initrd
			boot
			
		GRUB保护机制：
			password [--md5] 
				放置位置：
					第一个title之上：
						保护编辑功能；
					某title之内：
						保护内核使用；
			
			生成密码的命令：grub-md5-crypt
			
		修复GRUB？
			紧急救援模式进行修复；
			
			安装GRUB：
				完整安装：
					# grub-install [--root-directory=/path/to/somedir] /dev/DEVICE
				
				修复stage1
					# grub
					grub> root (hd#,#)
					grub> setup (hd#)
				
				提示：
					kernel /vmlinuz ro root=/dev/sda2 selinux=0 init=/bin/bash
					
					ldd /bin/bash
					chroot /mnt/sysroot/  /bin/bash
					
		GRUB 2: 
			特性：
				1) 图形接口；
				2) 模块化，支持动态装载和卸载；
				3) 支持脚本编辑；
				4) 支持rescue模式；
				5) 灵活的命令行接口；
				6) 设备命名：
					hd: 硬盘， fd: 软盘，设备从0开始编号，但分区从1开始编号，这不同grub legacy；
					
	
	Linux内核：
	
		单内核体系, 模块化
		
		内核的组成部分：
			核心文件：/boot/vmlinuz-VERSION
			模块文件：/lib/modules/VERSION/
				*.ko: 模块间或许存在依赖关系；
			ramdisk: 非必须性内容；
			
		内核模块管理：
			
			lsmod命令：列出已经装载的模块
				
				另一种办法：# cat /proc/modules
				
			modinfo: 查看指定模块的详细信息
				modinfo [OPTIONS] MOD_NAME
					-a: author
					-n: filename
					-l: license
					-p: parameters
					-d: description
					
				显示出的信息中：
					depends: 被此模块所依赖的其它模块；
					
			modprobe命令：
				实现模块的装载和卸载
				
				装载：modprobe MOD_NAME
					
					注意：会自动解决依赖关系；
				
				卸载：modprobe -r MOD_NAME
				
			手动实现模块文件装载和卸载
				insmod命令：
					insmod /path/to/module_file
					
					注意：不会自动解决依赖关系；
				
				rmmod命令：
					rmmod MOD_NAME
					
		与内核交互：
		
			/proc伪文件系统接口
			
				每个文件名均是内核参数，目录名为内核参数节点(子系统或子功能)信息；
					net.ipv4.ip_forward = 1
					/proc/sys/net/ipv4/ip_forward
					
					只读：输出内核信息
					读写：可修改的内核工作特性
						/proc/sys目录下
				
				伪文件系统：文件不能够直接使用编辑器编辑；修改方法：
					(1) echo 
						echo "New_Value" > /proc/sys/path/to/somefile
					(2) sysctl -w
						sysctl -w path.to.somefile=New_Value
						
						例如：/proc/sys/net/ipv4/ip_forward
						# echo "1" > /proc/sys/net/ipv4/ip_forward
						# sysctl -w net.ipv4.ip_forward=1
						
					注意：此两种设定立即生效，但内核重启后无效；
					
					(3) 内核参数配置文件/etc/sysctl.conf
						path.to.paramter = NEW_VALUE
						
						注意：此种设定不能立即生效；使其生效的方式：
						# sysctl -p
						
				查看当前运行中的内核的所有参数及其值：
					# sysctl -a
					
			/sys伪文件系统接口：
				伪文件系统：sysfs；主要用于输出内核识别出的各硬件设备的相关属性信息；还能够让用户修改某些参数的值来改变硬件的工作特性；
				
				用户空间的应用程序：udev通过读取/sys目录下保存硬件设备的相关信息来为每个当前内核探测到的硬件设备创建设备文件；创建设备文件的文件权限、名称等属性是可定制的；
					udev有规则文件：/etc/udev/rules.d/
					
					例如：修改网卡设备名字
						/etc/udev/rules.d/70-persistent-net 
							
			
		ramdisk：
			
			uname命令：
				-r: 内核的release号；
				-n: 主机名；
				-a: 显示所有信息；
			
			ramdisk制作：
				CentOS 5: mkinitrd
			
				CentOS 6: dracut, mkinitrd
				
					dracut [OPTION]... <image>  <kernel-version>
						-m LIST: 模块列表
						-d LIST: 驱动列表
					
					例如：# dracut /boot/initramfs-$(uname -r).img $(uname -r)
			
			手动修改：		
				展开initramfs文件：
					# cp initramfs-2.6.32-504.el6.x86_64.img /tmp
					# cd /tmp
					# mv initramfs-2.6.32-504.el6.x86_64.img initramfs-2.6.32-504.el6.x86_64.img.gz
					# gzip -d initramfs-2.6.32-504.el6.x86_64.img
					# mkdir ramdisk
					# cd ramdisk
					# cpio -id < ../initramfs-2.6.32-504.el6.x86_64.img
					
				归档：
					# find . | cpio -o -H newc --quiet > /boot/myramdisk.img
					# gzip /boot/myramdisk.img
					# mv /boot/myramdisk.img.gz /boot/myramdisk
					
			常用的内核参数：/proc/sys
				kernel.hostname：主机名
				net.ipv4.ip_forward: 本机的路由功能，开启或关闭在接口之间转发报文的功能；
				
			
	内核编译入门：
		必要性：
			(1) 替换有严重bug的老版本内核；
			(2) 测试新版本内核的功能，例如驱动的新硬件；
			(3) 学习内核编译；
			... ...
			
		准备工作：
			(1) 要充分获知目标硬件设备的信息；
			(2) 充分获知目标系统平台的各相关信息，如文件系统类型等；
			(3) 打算启用的新功能；
			(4) 准备好软件开发环境及内核源代码树；
			
		获取硬件设备信息：
			(1) CPU 
				# cat /proc/cpuinfo
				# lscpu
				# x86info -a
				
			(2) PCI
				# lspci [-v]
				# lsusb [-v]
				# lsblk 
				
			(3) hal-device
				hal: hardware abstract layer
				
		开发环境及源码：
			(1) 安装开发包组：
				Development Tools, Server Platform Development
				
			(2) 获取内核源码：
				www.kernel.org
				
			(3) 内核功能的选择
				选定配置：
					# make menuconfig
						[ ] 不启用此功能
						[M] 编译成内核模块
						[*] 编译进内核
						
					注意：要保存退出；所有选定的配置会保存在.config隐藏文件中；
				编译：
					# make
				安装内核模块：
					# make modules_install
					
					安装在/lib/modules/VERSION
				安装内核：
					# make install
				重启系统，选择使用新内核
				

回顾：
	CentOS启动流程之内核：
		GRUB Legacy:
			配置文件：/boot/grub/grub.conf
				default, timeout, splashimage, hiddenmenu, title, root (hd#,#), kernel /vmlinuz-VERSION, initrd
				
			ramdisk:
				initrd, initramfs
				
			grub安装：
				grub-install
				grub> setup (hd#)
				
			grub保护机制：
				password --md5 密码串
				
		模块管理：
			lsmod, modinfo, modprobe [-r] MOD_NAME, insmod, rmmod
			
		与内核交互：/proc, /sys
			
		ramdisk：dracut, mkinitrd
		
	内核编译：
		

Linux内核编译(2)及CentOS系统安装
	
	screen命令：
		打开：# screen
		终止：# exit
		拆除：Ctrl+a, d
		查看所有已经打开的screen ID：# screen -ls
		恢复连接至某screen: # screen -r SCREEN_ID
		
		# nohup make &
		
	内核编译的步骤：
	
		# make help：获取make命令的使用帮助
	
		选定配置(其中一种即可，但偶尔会结合两种或以上的方式进行)：
			# make config：遍历每个选项
			# make menuconfig：打开文本窗口
			# make xconfig：Qt窗口，依赖于KDE开发组件；
			# make gconfig：gtk窗口，依赖于GTK开发组件；
			# make allnoconfig: 所有可选择项均不选择；
			
			结果会保存至内核选项的配置文件中：.config
			
		编译：
			# make [-j #]
			
				多线程编译
				
		安装模块：
			# make modules_install
			
		安装内核：
			# make install
			
	内核编译进阶：
		
		1、在原有曾经编译过的内核源码基础上再次进行重编译之前，要清理源代码；
			# make clean: 保留.config配置文件及外部模块的相关文件；
			# make mrproper：删除所有编译生成的文件，包括.config和各种备份文件；
			# make distclean: 相当mrproper，以及删除编辑器备份及补丁文件；
			
		2、只编译其中部分代码：
			(1) 只编译选定目录中的代码
				# make dir/
				
			(2) 只编译一个模块
				# make dir/file.[oisS]
				
			(3) 完整编译一个模块
				# make dir/file.ko
			
		3、查看内核版本信息
			# make kernelrelease
			# make kernelversion
			
		4、只编译内核核心，不编译模块
			# make bzImage
			
		5、交叉编译
			编译操作所在的平台非目标代码运行的平台，事实上，目标代码将运行于另一个不同的平台； 
			
			# make ARCH=arch_name
			
			要获取目标平台的帮助：
				# make ARCH=arch_name help
				
			例如：
				# make ARCH=arm bockw_defconfig
			
			
	练习1：编译内核，并启用之；
	练习2：为运行于虚拟机上的CentOS 6添加一块新硬件，提供两个主分区；
		(1) 为硬盘新建两个主分区；并为其安装grub；
		(2) 为硬盘的第一个主分区提供内核和ramdisk文件； 为第二个分区提供rootfs；
		(3) 为rootfs提供bash、ls、cat程序及所依赖的库文件；
		(4) 为grub提供配置文件；
		(5) 启动目标主机；
		

CentOS系统安装 ：
	
	安装过程：通过安装程序anaconda来进行；
	
		bootloader --> vmlinuz, initrd.img --> anaconda
		
		anaconda支持两种模式：
			GUI：
			text
			
	anaconda把安装过程分成两个阶段：
		安装前配置阶段：
			键盘类型
			语言
			时区
			管理员密码
			磁盘及其分区方式
			要安装的程序包
		安装阶段:
			在目标磁盘创建分区、执行格式化；
			将选定的程序包安装至目标磁盘；
			生成bootloader；
		第一次启动
			配置iptables, selinux, core dump 
			
	系统安装的基本分区：
		/ : 根分区
		swap：交换分区
		
		注意：如果根分区放置于逻辑卷，由于grub无法驱动并访问逻辑卷，就必须将/boot单独分区，并使用基本磁盘分区
		
		/: 逻辑卷
			/usr
			/var 
			/home 
			/usr/local
			/tmp
			
		/boot：基本磁盘分区
		swap
		
	anaconda支持通过读取配置文件的内容来完成安装过程的配置：
		kickstart
		
		kickstart文件的组成：
			命令段
			程序包段：%packages, %end
				@group
				package
				-package
			脚本段：
				%pre 
					安装前脚本：安装过程开始之前要执行的脚本；
					注意：此时的Linux系统环境为微缩版环境，因此脚本应该较简单；
				%post
					安装后脚本：安装过程完成之后要执行的脚本；
					注意：脚本执行环境为完整的已经安装完成的系统； 
					
		kickstart命令段：
			必备命令
			可选命令
			
		配置kickstart的方式：
			(1) 手动编辑配置文件；
			(2) system-config-kickstart，GUI工具；
				程序包名同命令名；
				
		安装过程如何获取并使用kickstart文件：
			(1) 放置于安装程序能够获取到的位置；
				(a) 放置于光盘镜像；
				(b) 网络文件服务器；
					要求：安装程序得支持网络功能，且能够访问到网络文件服务器；
					
			
		安装过程的安装引导选项
			
			boot: 
				linux：默认安装模式 
				linux text：文本安装模式
				
			与网络相关的引导选项：
				ip=IPADDR
				netmask=MASK
				gateway=GW
				dns=DNS_SERVER_IP
				ifname=NAME:MAC_ADDR
				
			指明获取 kickstart 文件的路径：
				ks=
					DVD drive  ks=cdrom:/path/to/kickstart_file
					HTTP Server  ks=http://server_ip:port/path/to/kickstart_file
					HTTPS Server ks=https://server_ip:port/path/to/kickstart_file
					FTP Server   ks=ftp://serverip:port/path/to/kickstart_file
					NFS Server   ks=nfs:server_ip:/path/to/kickstart_file
					
		创建一个引导光盘：仅帮助启动安装过程，不提供安装树；
			(1) 准备工作目录，例如这里使用/tmp/cdrom；
			(2) 挂载系统发行光盘，复制isolinux目录至/tmp/cdrom；
			(3) 复制制作好的kickstart文件ks.cfg至/tmp/cdrom某位置；
			(4) 如果需要，可以编辑/tmp/cdrom/isolinux/isolinux.cfg 
				在某label后的append指令后附加ks=信息，从而实现自动调用光盘上提供的ks文件；
			(5) 创建iso镜像：				
			 # mkisofs -R -J -T -v --no-emul-boot --boot-load-size 4 --boot-info-table -V "CentOS 6.6 X86_64 boot disk" -b isolinux/isolinux.bin -c isolinux/boot.cat -o /root/boot.iso cdrom/
		
		PXE --> Cobbler
			
	博客作业：kickstart及引导镜像制作 ；


回顾：CentOS系统安装, kickstart
	
	iso: mbr --> boot.cat, isolinux.bin
		boot: linux text ip= netmask= ks=
			isolinux.cfg
	anaconda:
		安装前配置：键盘类型，语言环境，...
		安装执行过程：将用户选定要安装的程序包，基于安装树解决依赖关系后，执行安装程序包；
		第一次启动：设定iptables, selinux, core dump；

	kickstart文件：
		命令段：install, rootpw, authconfig, reboot, ...
		程序包段：%package, %end
			@group, package, -package
		脚本段：	
			%pre

			%post


CentOS Linux系统简单故障排除：

	grub:
		stage1: mbr
		stage1_5: mbr之后扇区，提供bootloader访问stage2所在的文件系统的驱动；
		stage2：/boot分区；

	grub的安装：
		grub-install
		grub> 

	rescue模式：紧急救援模式
		启动一个位于光盘上Linux系统，其会在启动过程中去检测本地的硬盘设备，并寻找原来的根文件系统，借助于此系统完成某些修复；
			此系统有自己的rootfs，但功能简陋；如果能找到硬盘上原来的根文件系统，可使用chroot切换至此rootfs，完成后续修复；


	示例：
		(1) 修复bootloader；
		(2) 重装程序包；

bash编程中的条件测试：
	条件测试：真，假

	bash中的条件测试：
		(1) 命令的执行状态结果，即命令成功与否；
			0: 成功
			1-255：失败

			在if语句上的用法：
				if COMMAND &> /dev/null; then
		(2) 条件测试表达式
			test EXPRESSION
			[ EXPRESSION ]
			[[ EXPRESSION ]]

			在if语句上的用法：
				if 条件测试表达式格式调用; then

	条件测试：
		整数测试：
			-eq, -ne, -lt, -le, -gt, -ge
		字符串测试:
			>, <, ==, !=, =~
			-n, -z
		文件测试：
			文件存在性及类型：-e, -f, -d, -h, -L, -b, -c, -S, -p
			文件属主、属组及权限：-O, -G, -x, -r, -w, -u, -g, -k
			文件时间戳：
			 	-N,
			 	-nt, -ot
			 硬链接：-ef

	组合测试条件1：组合测试表达式
		或：-o, [ COND_EXPR1 -o COND_EXPR2 ]
		与：-a
		非：! 	

		[ "$hname" == "localhost" -o "$hname" == "(none)" ]
			
	组合测试条件：组合测试语句
		与：&&
		或：||
		非：!

		[ "$hname" == "localhost" ] || [ "$hname" == "(none)" ]

		短路操作符：
			COND1 && COND2：
				COND1为“假”时，最终结果一定为“假”，因此COND2不用再测试；
				COND1为“真”时，最终结果取决于COND2；因此COND2一定会测试；

				由此，其相当于
					if COND1; then
						COND2
					fi

			COND1 || COND2
				COND1为“假”时，最终取决于COND2，因此COND2一定会测试；
				COND1为“真”时，最终结果一定为“真”，因此COND2不会做测试；

				由此，其相当于
					if ! COND1; then
						COND2
					fi

	多分支if语句：
		if COND1; then
			分支1
		elif COND2; then
			分支2
		...
		else
			分支n
		fi

		如果多个测试条件中是对同一个条件的多个不同取值进行测试，可替换简洁版的case；

	case语句：
		case 变量引用 in
			PATTERN1)
				分支1
				;;
			PATTERN2)
				分支2
				;;
			...
			*)
				分支n
				;;
		esac

			PATTERN可使用通配符：
				*: 任意长度任意字符；
				?: 任意单个字符；
				[]：指定范围内的任意单个字符；
				a|b|c：或者

	练习：写一个脚本
		(1) 能接受四个参数：start, stop, restart, status
			start: 输出“starting 脚本名 finished.”
			...
		(2) 其它任意参数，均报错退出；

		#!/bin/bash
		#
		svc=$(basename $0)
		lockfile=/tmp/${svc}

		case $1 in
		start)
		    if [ -e $lockfile ]; then
		         echo "$svc is running"
		         exit 0
		    else
		        echo "starting $svc finished."
		        touch $lockfile && exit 0
		    fi
		    ;;
		stop)
		    echo "stopping $svc finished."
		    ;;
		restart)
		    echo "restarting $svc finished."
		    ;;
		status)
		    echo "running or stopped."
		    ;;
		*)
		    echo "Usage: $svc {start|stop|restart|status}"
		    exit 1
		    ;;
		esac
		


SELinux: Secure Enhanced Linux
	
	NSA: 最小权限原则，任何进程运行时仅提供给它所需要最少资源；

	进程的安全上下文：
		进程：属主、属组
		文件：属主、属组

		httpd: apache apache
			/var/www/html/
				index.html
				index.php
				index.jsp

			httpd进程是否有权限访问/etc/fstab？

	主 谓 宾
		宝哥哥娶了林妹妹；
		subject,   动作, object

		subject: 进程
			动作：
		object: 文件，进程，...

	sandbox：沙箱
		进程：额外标签，domain
		资源：额外标签，type

		httpd: httpd_d
		/var/www/html: httpd_content_t

	SELinux：
		(1) 各进程有其domain标签，各资源有其type标签；
		(2) SELinux的规则库，定义了进程能够访问的资源；

	运作模型：
		strict：每个进程都受SELinux控制；
		targeted：仅部分被选定的进程受SELinux，额外的不接受控制；

	target模型下的SELinux的启用模式：
		enforcing：强制，即那些受限的进程必须严格按照规则库中的规则行为；
		permissive：许可，那些受限的进程访问不被规则允许的资源时不会受到阻止，但会被记录和警告；
		disabled：禁用；

	SELinux的配置文件：/etc/selinux/config <-- /etc/sysconfig/selinux
		修改配置文件：重启系统方能生效；

		命令：
			setenforce {1|0}
				1: enforcing
				0: permissive
			getenfoce

	如果要？？？启用SELinux：
		(1) 修改资源标签；
			d1 --> t1
				t2 -修改为-> t1
		(2) 修改进程的布尔型开关；
			进程有很多独立可功能可单独控制，尤其是有安全隐患的功能；

	修改标签：chcon
		chcon [OPTION]... [-u USER] [-r ROLE] [-l RANGE] [-t TYPE] FILE...
       	chcon [OPTION]... --reference=RFILE FILE...

    恢复默认标签：restorecon
    	restorecon [-P] PATH...

    布尔型开关：
    	getsebool [-a] [boolean]

    	setsebool [ -PV] boolean value | bool1=val1 bool2=val2 ... 
    		-P: 保存于策略库中；不使用-P选项，则仅当前这次系统运行有效；重启后无效；

    类型强制：type-enforce
    规则：
    	allow user_t bin_t: {read,write,getattr,setattr}

    查看SELiux状态：
    	sestatus

    DAC: discriptionary access control
    MAC: mandatory access control


回顾：
	rescue，case语句, SELinux

	rescue：启动一个运行于ram中仅具有基本修复工具的系统；

	case语句：
		case 变量引用 in
		PATTERN1)
			分支1
			;;
		PATTERN2）
			分支2
			;;
		...
		*)
			分支n
			;;
		esac

	SELinux：
		命令：getenforce, setenforce, getsebool, setsebool, sestatus, chcon, restorecon

		配置文件：/etc/selinux/config

bash脚本编程：

	1、交互式编程
		read [-ers] [-a array] [-d delim] [-i text] [-n nchars] [-N nchars] [-p prompt] [-t timeout] [-u fd] [name ...]
			-p prompt
			-t timeout
			-a array
				name为数组，而非变量
			-A array
				name为关联数组；

		示例：写一个脚本，显示用户选定要查看的信息；
		cpu) display cpu info
		mem) display memory info
		disk) display disk info
		*) quit

	练习：写一个脚本，提示用户输入一个用户名；
		在用户存在时，判断其UID是否同GID；
		同，则显示“Good guy”， 不同，则显示“Bad guy”；

		#!/bin/bash
		#
		read -p "Plz enter a user name: " name

		! id $name &> /dev/null && echo "No this user." && exit 1

		if [ `id -u $name` == `id -g $name` ]; then
		    echo "Good guy"
		else
		    echo "Bad guy"
		fi

		第二种实现方式：
		[ `id -u $name` == `id -g $name` ] && echo "good guy" || echo "bad guy"	

	2、循环
		循环执行：for
			for Var_Name in LIST; do
			for ((i=0;i<=100;i++)); do

		(1) while循环；

			while CONDITION; do
				循环体
				循环控制变量的修正表达式
			done

			其中，“CONDITION”，当条件测试结果为“真”，则进入循环；为“假”时，终止循环；
				循环控制变量要用于CONDITION中，以实现循环条件构建；

			示例：求100以内所在正整数之和；
				#!/bin/bash
				#
				declare -i sum=0
				declare -i i=1

				while [ $i -le 100 ]; do
				    let sum+=$i
				    let i++
				done

				echo "$sum"	
				
			示例：添加10个用户，user1-user10; 

				#!/bin/bash
				#
				declare -i i=1

				while [ $i -le 10 ]; do
				    ! id user$i &> /dev/null && useradd user$i && echo "Add user$i finished." || echo "user$i exists."
				    let i++
				done

			示例：打印九九乘法法；

				#!/bin/bash
				#
				declare -i i=1

				while [ $i -le 9 ]; do
				    let j=1
				    while [ $j -le $i ]; do
				        echo -n -e "${j}X${i}=$[$i*$j]\t"
				        let j++
				    done
				    echo 
				    let i++
				done

			示例：写一个脚本，判断给定的用户是否登录了当前系统；
				(1) 如果登录了，则显示用户登录，脚本终止；
				(2) 每3秒钟，查看一次用户是否登录；

				#!/bin/bash
				#
				read -p "Plz enter a user name: " name

				while ! who | grep "^$name\>" &> /dev/null; do
				    sleep 3
				done

				echo "$name is here."	
				
			示例：写一个脚本，显示用户选定要查看的信息；
			cpu) display cpu info
			mem) display memory info
			disk) display disk info
			quit) quit

			非此四项选择，则提示错误，并要求用户重新选择，只到其给出正确的选择为止；


				#!/bin/bash
				#
				cat << EOF
				                cpu) display cpu info
				                mem) display memory info
				                disk) display disk info
				                quit) quit
				EOF

				read -p "your option: " option

				while [ "$option" != 'cpu' -a "$option" != 'mem' -a "$option" != 'disk' -a "$option" != 'quit' ]; do
				    echo "Wrong option."
				    read -p "your option again: " option
				done

				case $option in
				cpu)
				     lscpu ;;
				mem)
				     free ;;
				disk)
				     fdisk -l /dev/[sh]d[a-z] ;;
				quit)
				     exit 0
				esac	
				
		(2) until循环

			until CONDITION; do
				循环体
				控制变量修正语句
			done

			CONDTION条件为“假”时，执行循环；为“真”时退出循环；

			示例：100以内所有正整数之和：

				#!/bin/bash
				#
				declare -i i=1
				declare -i sum=0

				until [ $i -gt 100 ]; do
				    let sum+=$i
				    let i++
				done

				echo "$sum"

			示例：添加10个用户，tuser1-tuser10; 	
			
		(3) while循环的特殊用法：

			(a) 用于遍历指定文件的每一行；
				while read 变量名; do
					循环体
				done < /PATH/TO/SOMEFILE

				变量用于保存一行数据；直到遇到文件尾，数据终止，循环退出；

				示例：找出其UID为偶数的用户，显示用户名和其UID；

					#!/bin/bash
					#
					[ $UID -ne 0 ] && echo "Only root can excute this script." && exit 1

					while read line; do
					    userid=$(echo $line | cut -d: -f3)
					    if [ $[$userid%2] -eq 0 ]; then
					        echo $line | cut -d: -f1,3
					    fi
					done < /etc/passwd	
					
				示例：将给定的偶数行内字符统统修改为大写之后输出；

					#!/bin/bash
					#
					declare -i linenumber=1
					read -p "Plz enter a file path: " file

					while read line; do
					    if [ $[$linenumber%2] -eq 0 ]; then
					        echo -n "$linenumber "
					        echo $line |tr 'a-z' 'A-Z'
					    fi
					    let linenumber++
					done < $file

			(b) 死循环
				while true; do
					循环体
				done

		循环控制：
			break [N]：结束循环；
				退出当前循环；N表示循环嵌套层次；
			continue [N]：提前结束本轮循环，而直接进入下一轮循环条件判断


			while CONDITION1; do
				statement1
				...
				if CONDITION2; then
					break [N]
				fi
				statementN
				statementN+1
				...
			done

			示例：求100以内所有偶数之和；

				#!/bin/bash
				#
				declare -i evensum=0
				declare -i i=0

				while [ $i -le 100 ]; do
				    let i++
				    if [ $[$i%2] -eq 1 ]; then
				        continue
				    fi
				    let evensum+=$i
				done

				echo "$evensum"

			示例：判断centos是否登录，如果登录则显示之；否则，每3秒查看centos是否登录；

				#!/bin/bash
				#
				user='centos'
				while true; do
				    if who | grep "^$user\>" &> /dev/null; then
				        break
				    fi
				    sleep 3
				done

				echo "$user is here."

	函数：function，功能
		把一段代码组织成一个独立个体，并且被赋予了名字；需要用到此段代码时，只需要执行处给出名字（函数名）即可；
			提高代码重用率
			模块化编程

		语法结构：
			function f_name {
				函数体
			}

			f_name() {
				函数体
			}

		调用函数：函数名
			函数名出现的地方，自动替换为函数代码；

			注意：函数不调用，其不会执行；

		函数的返回值：
			函数执行过程结果向调用者的回馈；
				(a) 显式使用echo或printf命令；
				(b) 函数中某些命令运行结果产生的输出；
			函数退出状态码：
				默认其退出码取决于函数体最后执行的那个语句的退出状态码；
				自定义退出状态码：
					return [N]
						0-255
							0：成功
							1-255: 失败

					注意：函数运行时，一旦遇到return语句即会退出整个函数的运行；

		函数可接受参数：
			调用函数时，可以传递参数给函数，传递方法类似向脚本传递参数的方法，例如
				f_name arg1 arg2 arg3 ...

				在函数中可使用$1, $2, ...来调用这些参数；
				可在函数中使用特殊变量：$#, $@, $*

		练习：写一个脚本
			(1) 用函数实现返回一个用户的UID和SHELL；用户名通过参数传递而来；
			(2) 提示用户输入一个用户名或输入“quit”退出；
				当输入的是用户名，则调用函数显示用户信息；
				当用户输入quit，则退出脚本；

			进一步地：显示键入的用户相关信息后，再次提醒输出用户名或quit: 

		练习：写一个脚本，完成如下功能（使用函数）
			(1) 提示用户输入一个可执行命令的名字；获取此命令依赖的所有库文件；
			(2) 复制命令文件至/mnt/sysroot目录下的对应的rootfs的路径上，例如，如果复制的文件原路径是/usr/bin/useradd，则复制到/mnt/sysroot/usr/bin/目录中；
			(3) 复制此命令依赖的各库文件至/mnt/sysroot目录下的对应的rootfs的路径上；规则同上面命令相关的要求；

	

























	

				
					
			
					
				
			
		
				
					
				
				
				
				
				
			
				
			
					
					
				
				
				
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
				
			
		
				
				
			
				
		
		
			
				
				
			
			
			
					
		
			
		
			
	
		
		
					
				
									
								
									
								
									
									
								
							
								
							
							
							
						
							
					
					
					
			
				
					
			
				
				
			
						
				
				
		
		
	
		
			
			
	
		
	  
	      
	    
		
	
	    
	
	
	

      






















































































































































































































		
















