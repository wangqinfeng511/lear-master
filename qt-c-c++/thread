线程：
	void test(){
		printf("%s","Hello Word");
	}
	std::thread t1(test);
	t1.join() //阻塞运行
	t1.detach() //线程运行
错误捕获：
	try{
		for(int i=0;i<10;i++){
			std::thread t1.detach();
		}
	catch(...) //捕获所有错误
		{
			throw; //正常输出错误。

		}	
	}
锁：
	std::mutex mu;
	mu.lock();
	y=20;
	mu.unlock()
线程安全自解锁：
	1 {
		std::mutex mu;
		std::unique_lock<std::mutex>lock(mu)
		y=23;
	  }

	2 {
		std::mutex mu;
    		std::unique_lock<std::mutex>lock(mu,std::try_to_lock); //表示不阻塞等待锁
    		if(lock.owns_lock()){ //拿到锁怎么处理;

    		}else { //没拿到锁怎么处理

    		}	
	}
	3 {
		std::mutex mu;
    		std::unique_lock<std::mutex>lock(mu,std::defer_lock); //表示未加锁
    		lock.lock();
    		y=100;
    		lock.unlock();
	}
线程某对象在所有线程只运行一次;
	void set_winner(int x) { printf("%d",12); };
	std::once_flag flag;
	std::call_once(flag,set_winner,1);
全局条件变量：
	#include <condition_variable>
	std::condition_variable cond;
	std::mutex mu;
	void set_winner() {
    		QThread::msleep(10000);
    		cond.notify_one();
    		printf("%d",12); };

	void test(){
   	std::unique_lock<std::mutex>lock(mu,std::defer_lock);
   	cond.wait(lock); 阻塞等待set_winner执行cond.notify_one();
    	printf("%s","hello worder");
   	fflush(stdout);
	}	
	int main(int argc, char *argv[])
	{
    		std::thread t2(set_winner);
    		std::thread t1(test);
    		t2.detach();
    		t1.detach();
	}
