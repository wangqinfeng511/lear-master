一.学习笔记
	Template
		verctor<list<int>>;
	auto 自动类型
	一致性初始化：
		std::vector<int> v {1,2,3,4,5};
		int array[]={1,2,3,4,5}
	for循环：
		for(int i:{1,2,3,4,5}){};
		for(auto i:v){};
	Move语义：
		std::move()
	字符串字面常量：
		Raw string:R"abacesx";以R装饰,字符序列，比如输出\\n不需要\\\\n
		u定义一个string literal 类型为char16_t的字符．
		U定义一个string literal 类型为char32_t的字符．
		L定义一个wide string literal 类型为wchar_t的字符．
	noexcept:不抛出异常．
		void foo() noexcept{}
	异常捕获：
		try{
			throw std::runtime_error("错误") //手动触发异常
		} catch(...){ //捕获所有异常．
			throw;
		}
	自定义异常：
		struct MyException:public exception{
			const char* what() const throw(){
				return "返回自定义错误"
			}
		}
		try{ throw MyException()
		}catch(MyException &e){
			std::cout<<e.what()<<std::endl;
		}
	常用异常：
		std::exception	该异常是所有标准 C++ 异常的父类。
		std::bad_alloc	该异常可以通过 new 抛出。
		std::bad_cast	该异常可以通过 dynamic_cast 抛出。
		std::bad_exception	这在处理 C++ 程序中无法预期的异常时非常有用。
		std::bad_typeid	该异常可以通过 typeid 抛出。
		std::logic_error	理论上可以通过读取代码来检测到的异常。
		std::domain_error	当使用了一个无效的数学域时，会抛出该异常。
		std::invalid_argument	当使用了无效的参数时，会抛出该异常。
		std::length_error	当创建了太长的 std::string 时，会抛出该异常。
		std::out_of_range	该异常可以通过方法抛出，例如 std::vector 和 std::bitset<>::operator[]()。
		std::runtime_error	理论上不可以通过读取代码来检测到的异常。
		std::overflow_error	当发生数学上溢时，会抛出该异常。
		std::range_error	当尝试存储超出范围的值时，会抛出该异常。
		std::underflow_error	当发生数学下溢时，会抛出该异常。
	保存异常
		catch(....){        
			std::exception_ptr eptr;
        		eptr=std::current_exception();
		}
	lambda:
		    auto l= []{qDebug()<<"test";};
    		     l();:
		传参：不可以是template
		[](const int &a){qDebug()<<a}(12);直接调用
		作用域：
		　　要访问没有传入lambda内的对象．需要引入
		    int a=10;
    		　　[&a]{qDebug()<<a;}();
	decltype:函数返回类型
			
