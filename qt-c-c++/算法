啊哈算法
一、桶排序
	遍历数组把数据放入桶中！
	代码：
	vector<int> data={10,8,9,12,4,5,6,7}
	int tong[10];//创建十个整数桶
	int i,j;
	//循环放入桶中
	for (i=0;i<data.size();i++){
		tong[data[i]]+=1;
	}
	//遍历输出
	int dsdata[data.size];
	for(i=0;i<tong.size;i++){
		for(j=0;j<tong[tong[i]];j++){
			dsdata[i]=tong[i];
		}		
	}
二、冒泡排序
	向后比较如果‘大于’左右对掉;
	vector<int> data={1006,1,2,7,9,6,1,2,7,9};
	int tmp,i,j;
	void ds(){
    		for(i=0;i<data.size();i++){
        		for(j=0;j<data.size()-i;j++){
            			//逐次把大的值往右送，最后送到data.size-i的位置
            			if(data[j]>data[j+1] and (j+1)<data.size()){
                			tmp=data[j+1];
                			data[j+1]=data[j];
                			data[j]=tmp;
            			}
            			qDebug()<<data<<j;
        			}

    		}
	}
三、快速排序
	using namespace std;
	vector<int> data={6,1,2,7};
	void ds(size_t left,size_t right){
    		int base,i,j,tmp;
    		i=left,j=right;
    		qDebug()<<"left:"<<left<<"right"<<right;
    		if(left>right){qDebug()<<"退出";return;}
    			base=data[left];//取出基准值
    			while (j!=i) {
        			while (data[j]>base && j>i) {j--;}
        			while (data[i]<=base && j>i) {i++;}
        			if(i<j){
            				tmp=data[i];
            				data[i]=data[j];
            				data[j]=tmp;
        				}
    				}
    				data[left]=data[j];
    				data[j]=base;
    				qDebug()<<data<<j<<i;
    				ds(left,i-1);
    				ds(i+1,right);

				};
		int main(int argc, char *argv[])
			{		
    			ds(0,data.size()-1);
    			return  0;
		}
//输出：
	left: 0 right 3
	std::vector(2, 1, 6, 7) 2 2
	left: 0 right 1
	std::vector(1, 2, 6, 7) 1 1
	left: 0 right 0
	std::vector(1, 2, 6, 7) 0 0
	left: 0 right 18446744073709551615
